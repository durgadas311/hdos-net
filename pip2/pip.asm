.PIP.	EQU	0	; '0' is TRUE	ASSEMBLE AS PIP
ONECOPY EQU	1	;	DONT ASSEMBLE AS ONECOPY

	IF	.PIP.
	STL	''
	ELSE
	TITLE	'ONECOPY - ONE DRIVE COPY UTILITY'
	ENDIF


***	PIP - PERIHPERAL INTERCHANGE PROGRAM.
*
*	  J. G. L , 11/1977 FOR *HEATH* COMPANY
*
*	COPYRIGHT 1977 BY HEATH COMPANY
*
*	      G. C.,	78/09	Maintenence Release
*			79/04
*
*			79/11	50.05.00
*			80	50.06.00
*				 /2.0a/ = /80.09.gc/
*				 /2.0b/ = /80.10.gc/
*
	SPACE	4,10
***	USE:
*
*	DEST=SOURCE1 [,SOURCE2,...,SOURCEN] L/SWITCH1.../SWITCHN:
*
*	SWITCHES:
*
*	/ALL[OCATE]
*	/R[ENAME]		RENAME
*	/DEL[ETE]	DELETE
*	/L[IST]		LIST
*	/B[RIEF]	BRIEF LIST
*	/S[YSTEM]	ENCLUDE SYSTEM FILES
*	/V[ERSION]	PIP VERSION NUMBER
*	/MOU[NT]	MOUNT DEVICE
*	/DIS[MOUNT]	DISMOUNT DEVICE
*	/RES[ET]	RESET DEVICE
*
*	/SU[PRESS]	SUPRESS
*	/JGL		WHO?
	EJECT
**	SYSTEM EQUIVALENCES

CN.SOU	EQU	0		SOURCE CHANNEL NUMBER
CN.DES	EQU	1		DESTINATION CHANNEL NUMBER
CN.DIR	EQU	2		DIRECTORY CHANNEL NUMBER

**	PROGRAM ERROR CODES

PEC.DF	EQU	200Q		DEVICE FORMAT ERROR
PEC.DNC EQU	201Q		DEVICES NOT CONSISTANT
PEC.TFI EQU	203Q		TARGET FILE ILLEGAL
PEC.CS	EQU	204Q		CONTRADICTORY SWITCHES
PEC.IUW EQU	205Q		ILLEGAL USE OF WILDCARD
PEC.IDF EQU	206Q		ILLEGAL DESTINATION FILE FORMAT
PEC.SFI EQU	207Q		SOURCE FILE ILLEGAL
	IF	ONECOPY
PEC.FCI EQU	210Q		FILE CONCATINATION ILLEGAL
	ENDIF

	XTEXT	U8250
	XTEXT	U8251
	XTEXT	DIRDEF
	XTEXT	DIFDEF
	XTEXT	OVLDEF
	XTEXT	DEVDEF
	XTEXT	IOCDEF
	XTEXT	DISDEF
	XTEXT	FBDEF
	XTEXT	ECDEF
	XTEXT	HOSEQU
	XTEXT	HOSDEF
	XTEXT	ASCII
	XTEXT	ESINT
	XTEXT	ESVAL
	XTEXT	DDDEF
	XTEXT	MTR
	XTEXT	DDFDEF
	XTEXT	LABDEF
	XTEXT	FILDEF
	XTEXT	ABSDEF
	STL	'MAIN ROUTINE'
	EJECT
*	Code header from original (cross-assembler)		/19.07.gr/
*	ORG	USERFWA-ABS.COD
*	DB	377Q,FT.ABS
*	DW	USERFWA		LOAD ADDRESS
*	DW	MEML-USERFWA	SIZE
*	DW	ENTRY		ENTRY
	ORG	USERFWA		ORG for Heath assembler		/19.07.gr/

	IF	ONECOPY

*	Since this code overlays PRS, it is included here		/2.0a/

PRS3	CALL	GETLAB		Get Label
	RC
	LXI	B,256
	LXI	D,LABEL
	LXI	H,SLABEL
	CALL	$MOVE		Save Current Label

	CALL	MND		Mount New Disk
	JC	ERROR
	LDA	LABEL+LAB.SER
	STA	VOLSER		Set Current Volume Number
	JMP	START

	ENDIF

PIP	EQU	*

*	COMMAND INTERPRETATION COMES HERE

RESTART EQU	*

	LDA	MODE
	ANA	A
	JNZ	EXIT		ENTERED WITH COMMAND, WILL NOW EXIT
START	LXI	SP,STACK	CLEAN STACK
	CALL	PIP1		EXECUTE COMMAND

*	COMMANDS EXIT HERE IF NO ERRORS FOUND

	JMP	RESTART

*	GET READY TO PROCESS COMMAND

PIP1	CALL	SDD		SET DEFAULT DEFAULT

*	CLEAR CHANNELS AND FILE BUFFER

	DB	SYSCALL,.CLEARA CLEAR CHANNELS
	XRA	A
	STA	DESTFB+FB.FLG	FLAG FILE NOT OPEN

*	CLEAR DYNAMIC BUFFERS

	LXI	H,0
	SHLD	BUFSIZ		EMPTY BUFFER
	SHLD	NAMTLEN		CLEAR NAMTAB
	SHLD	NAMTMAX		CLEAR NAMTAB AREA
	LXI	H,BUFF
	SHLD	BUFPTR		SET BUFFER AGAINST END OF NAMTAB

*	INPUT COMMAND LINE

	CALL	$CCO		CLEAR CONTROL-O
	LDA	MODE
	ANA	A
	CZ	ACL		ACCEPT COMMAND LINE (UNLESS WAS PASSED ONE BY CALLER)
	JC	EXIT		EOF
	LXI	H,LINE		(HL) = COMMAND ADDRESS
	LXI	D,PIPA		(DE) = SWITCH LIST
	ERRNZ	I.COP
	XRA	A		(A) = #I.COP
	STA	COMAND		ASSUME COPY COMMAND
	STA	SUPRES		CLEAR /SUP FLAG
	STA	ALLOCA		Clear /ALL flag			/80.06.gc/
	INR	A		FLAG NO /S FLAG
	STA	SYSTEM		CLEAR /S FLAG
	CALL	$DRS		DETECT AND REMOVE SWITCHES
	JC	ERROR		ERROR
	LDA	COMAND
	CALL	$TJMP		PROCESS COMMAND
	EJECT
**	COMMAND LIST

PIPB	DS	0		COMMAND PROCESSOR TABLE
I.COP	EQU	*-PIPB/2		COMMAND INDEX
	DW	COPY
I.LIS	EQU	*-PIPB/2		COMMAND INDEX
	DW	LIST
I.BRE	EQU	*-PIPB/2		COMMAND INDEX
	DW	BRIEF		/BR
I.VER	EQU	*-PIPB/2		COMMAND INDEX
	DW	VERSN		/V
I.MOU	EQU	*-PIPB/2	/MOU,/M
	DW	MOUNT
	IF	.PIP.
I.DEL	EQU	*-PIPB/2
	DW	DELETE		/DEL
I.REN	EQU	*-PIPB/2
	DW	RENAME		/RE
I.DIS	EQU	*-PIPB/2
	DW	DISMOU		/DIS
I.RES	EQU	*-PIPB/2
	DW	RESET		/RES
	ENDIF

*	CTL-D HIT

EXIT	XRA	A
	DB	SYSCALL,.EXIT	EXIT
	SPACE	4,10
**	CCHIT - CTL-C HIT
*
*	ENTRY	FROM SYSTEM


CCHIT	CALL	$TYPTX
	DB	'^','C'+200Q
	DB	SYSCALL,.CLRCO	CLEAR CONSOLE TYPEAHEAD
	JMP	RESTART		GET NEW COMMAND
	STL	'SWITCH PROCESSING TABLES AND ROUTINES'
	EJECT
***	SWITCH PROCESSING TABLES AND ROUTINES.
*
*	COMMAND SWITCHES ARE PROCESSED VIA THE ROUTINE $DRS, 'DECODE AND
*	REMOVE SWITCHES'. $DRS IS SUPPLIED WITH A SWITCH DESCRIPTION
*	TABLE, WHICH CONTAINS THE ADDRESSES OF ROUTINES
*	WHICH ARE ENVOKED WHEN THE SWITCHES ARE ENCOUNTERED.


**	SWITCH TABLE

PIPA	DS	0		FWA SWITCH TABLE
	IF	.PIP.
	DB	'DEL'		/DELETE
	DB	'E'+200Q,'T'+200Q,'E'+200Q,200Q
	DW	SW.DEL		 PROCESSING ROUTINES

	DB	'R'		/RENAME
	DB	'E'+200Q,'N'+200Q,'A'+200Q,'M'+200Q,'E'+200Q,200Q
	DW	SW.REN		 PROCESS RENAME

	DB	'DIS'		/DISMOUNT
	DB	'M'+200Q,'O'+200Q,'U'+200Q,'N'+200Q,'T'+200Q,200Q
	DW	SW.DIS

	DB	'RES'		/RESET
	DB	'E'+200Q,'T'+200Q,200Q
	DW	SW.RES
	ENDIF

	DB	'ALL'		/ALLOCATE			/80.06.gc/
	DB	'O'+200Q,'C'+200Q,'A'+200Q,'T'+200Q,'E'+200Q,200Q /.06.gc/
	DW	SW.ALL						/80.06.gc/

	DB	'L'		/LIST
	DB	'I'+200Q,'S'+200Q,'T'+200Q,200Q
	DW	SW.LIS		 PROCESS LIST

	DB	'B'		/BRIEF
	DB	'R'+200Q,'I'+200Q,'E'+200Q,'F'+200Q,200Q
	DW	SW.BRE		 PROCESS BRIEF

	DB	'V'		/VERSION
	DB	'E'+200Q,'R'+200Q,'S'+200Q,'I'+200Q,'O'+200Q,'N'+200Q,200O
	DW	SW.VER		PROCESS VERSION

	DB	'MOU'		/MOUNT
	DB	'N'+200Q,'T'+200Q,200Q
	DW	SW.MOU

	DB	'S'		/SYSTEM
	DB	'Y'+200Q,'S'+200Q,'T'+200Q,'E'+200Q,'M'+200Q,200Q
	DW	SW.SYS		 PROCESS SYSTEM

	DB	'SU'		/SUPRESS
	DB	'P'+200Q,'R'+200Q,'E'+200Q,'S'+200Q,'S'+200Q,200Q
	DW	SW.SUP

	DB	'JGL'		/JGL INTERNAL SWITCH
	DB	200Q
	DW	SW.JGL

	DB	0		END OF TABLE
	EJECT
	IF	.PIP.
	SPACE	3
**	SW.DEL - /DELETE SWITCH DETECTED.

SW.DEL	MVI	A,I.DEL
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.REN - /RENAME SWITCH DETECTED.

SW.REN	MVI	A,I.REN
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.DIS	-  /DISMOUNT SWITCH DETECTED

SW.DIS	MVI	A,I.DIS
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.RES	-  /RESET SWITCH DETECTED.

SW.RES	MVI	A,I.RES
	JMP	SWIT1		IS MAJOR FUNCTION
	ENDIF
	SPACE	3
*	SWIT1 - PROCESS MAJOR FUNCTION SWITCH.
*
*	SWIT1 IS ENTERED TO PROCESS SWITCHES WHICH DETERMINE THE FUNCTION
*	PIP IS TO PERFORM. I.E. 'VERB' SWITCHES, SUCH
*	AS /DELETE (AS OPOSED TO 'MODIFIER' SWITCHES, LIKE /SYSTEM)

SWIT1	LXI	B,COMAND
	PUSH	PSW		SAVE COMMAND
	LDAX	B		(A) = PREVIOUS COMMAND
	ANA	A
	MVI	A,PEC.CS	CONTRADICTORY SWITCHES
	JNZ	ERROR		IF SO
	POP	PSW		(A) = NEW CODE
	STAX	B		STORE IT
	RET
	EJECT
**	SW.ALL	- /ALLOCATE Switch Detected			 80.06.gc/

SW.ALL	MVI	A,1
	STA	ALLOCA
	RET
	SPACE	3
**	SW.SYS - /SYSTEM SWITCH DETECTED.

SW.SYS	XRA	A		SET /S FLAG
	STA	SYSTEM
	RET
	SPACE	4
**	SW.SUP - /SUPPRESS SWITCH.


SW.SUP	MVI	A,1
	STA	SUPRES
	RET
	SPACE	4
**	SW.JGL - /JGL SYSTEM SWITCH.


SW.JGL	MVI	A,1
	STA	JGL
	MVI	A,'C'
	STA	PFIB1		SET 'C' CHARACTER FOR FLAGS DISPLAY
	JMP	SW.SYS
	SPACE	3
**	SW.BRE - /BRIEF SWITCH DETECTED.

SW.BRE	LDA	COMAND		ALLOW TO SUPERCEDE /LIST
	ANA	A
	JZ	SW.BRE1		NO OTHER COMMAND
	ERRNZ	I.LIS-1
	DCR	A
	MVI	A,PEC.CS	ASSUME CONTRADICTORY SWITCHES
	JNZ	ERROR
SW.BRE1 MVI	A,I.BRE		IS /BREIF
	STA	COMAND
	RET
	EJECT
**	SW.LST - /LIST SWITCH DETECTED.

SW.LIS	LDA	COMAND
	ANA	A
	JZ	SW.LIS1		NO FUNCTION
	ERRNZ	I.BRE-2
	ERRNZ	I.LIS-1
	SUI	3
	CMC
	RNC			ALREADY HAVE ONE SPECIFIED, I.BRE OVERRULES
SW.LIS1 MVI	A,I.LIS		/LIST
	STA	COMAND
	RET
	SPACE	3
**	SW.VER	- /VERSION SWITCH DETECTED

SW.VER	MVI	A,I.VER
	JMP	SWIT1
	SPACE	3
**	SW.MOU	- /MOUNT SWITCH DETECTED

SW.MOU	MVI	A,I.MOU
	JMP	SWIT1
	LON	LGCR
	STL	'COPY - PROCESS COPY COMMAND.'
	EJECT
***	ACL - ACCEPT COMMAND LINE.
*
*	ACL PROMPTS FOR AND READS A COMMAND LINE FROM
*	THE CONSOLE.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR, GOT LINE
*		 'LINE' = COMMAND LINE
*		'C' SET IF EOF
*	USES	ALL


ACL	CALL	$GNL		GUARANTEE NEW LINE
	CALL	$TYPTX
	IF	.PIP.
	DB	':P',':'+200Q
	ELSE	ONECOPY
	DB	':OC',':'+200Q
	ENDIF
	XRA	A
	STA	S.CSLMD		CLEAR SPECIAL MODES
	LXI	H,LINE
	JMP	$RTL.		READ UPPER CASE LINE AND EXIT
	STL	'COPY - PROCESS COPY COMMAND.'
	EJECT
	IF	.PIP.		PIP USES 'COPY'
***	COPY - PROCESS COPY COMMAND.
*
*	SYNTAX:
*
*	DEST=SOURCE1,...,SOURCEN
*
*	D'DEST' IS THE DESTINATION FILE DESIGNATOR. IF NULL
*	(IN WHICH CASE THE '=' MAY BE OMITTED) IT DEFAULTS  TO
*		KB:PIPDEST.JGL
*
*	THE 'SOURCE' FIELDS ARE THE SOURCE FILE DESIGNATORS. WILDCARDS
*	MAY BE USED FOR FILE NAME AND EXTENSION.
*	IF NO WILDCARDS ARE USED IN THE DESTINATION, MULTIPLE SOURCE FILES
*	ARE CONCATINATED TOGETHER.
*
*	IF WILDCARDS ARE PRESENT IN THE DESTINATION FILE DESCRIPTION,
*	THE SOURCE FILES ARE COPIED TO INDIVIDUAL OUTPUT FILES. THE
*	NAMES OF THE OUTPUT FILES ARE CREATED BY FILLING
*	THE 'WILD' SPOTS IN THE DESTINATION NAME WITH THE CORRESPONDING
*	CHARACTERS IN THE SOURCE NAME.


COPY	EQU	*
	XRA	A
	STA	COPYC		CLEAR FILE COUNT
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR		ERROR
	STA	COPYA		SAVE DESTIONATION TYPE
	CALL	SDD		RESET DEFAULT DEFAULTS
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR
	CALL	$MOVEL
	DW	COPYDL
	DW	DESTFB+FB.NAM
	DW	COPYD		SAVE WILDCARD DESTINATION

*	HAVE DESTINATION AND SOURCE FILE NAMES. DO THE COPYING.
*
*	IF NO DESTINATION WILD CARDS, THUS COPIING TO A SINGLE OUTPUT
*	FILE, OPEN THAT FILE NOW.

	LDA	COPYA
	ANA	A
	JZ	COPY1		IS WILDCARDED
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES	(A) = DESTINATION CHANNEL
	DB	SYSCALL,.OPENW		OPEN IT
	LXI	H,DESTFB
	JC	$FERROR		IF ERROR

*	OPEN NEXT SOURCE FILE

COPY1	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	COPY5		NO MORE INPUT FILES
	LXI	H,COPYC
	INR	M		COUNT FILE
	LXI	H,NAMTAB	(HL) = NAME ADDRESS
	MVI	A,CN.SOU	SOURCE CHANNEL
	DB	SYSCALL,.OPENR	OPEN FOR READ
	JC	NAMERR		IF ERROR

*	OPEN DESTINATION FILE IFF WILDCARDS

	LDA	COPYA
	ANA	A
	JNZ	COPY2		NOT WILDCARDS
	LXI	B,COPYD		(BC) = WILDCARD PATTERN ADDRESS
	LXI	D,NAMTAB	(DE) = SOURCE NAME
	LXI	H,DESTFB+FB.NAM (HL) = RESULT AREA
	PUSH	H		SAVE POINTER TO RESULT AREA
	CALL	MWN		MERGE WILDCARD NAME
	POP	H		(HL) = #DESTFB+FB.NAM
	MVI	A,CN.DES
	DB	SYSCALL,.OPENW
	LXI	H,DESTFB
	JC	$FERROR		CANT GET FILE OPEN

*	INPUT AND OUTPUT FILES OPEN. COPY

COPY2	CALL	EBM		EXPAND BUFFER TO MAX SIZE
COPY3	LHLD	BUFSIZ
	MOV	B,H
	MOV	C,L		(BC) = LENGTH OF BUFFER
	LHLD	BUFPTR
	XCHG			(DE) = BUFFER FWA
	MVI	A,CN.SOU
	PUSH	D
	DB	SYSCALL,.READ
	POP	D		(DE) = BUFFER FWA
	PUSH	PSW
	JNC	COPY4		GOT IT ALL
	CPI	EC.EOF
	JE	COPY4		IS EOF
	POP	PSW		RESTORE ERROR CODE
	JMP	NAMERR

COPY4	LDA	BUFSIZ+1	(A) = # OF SECTORS IN BUFFER
	SUB	B
	MOV	B,A		(B) = SECTORS READ
	MVI	C,0
	MVI	A,CN.DES
	DB	SYSCALL,.WRITE	WRITE IT OUT
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON WRITE
	POP	PSW		(PSW) = STATUS FROM READ
	JNC	COPY3		NOT EOF
	CALL	SBE		SHRINK BUFFER TO MINIMUM SIZE
	MVI	A,CN.SOU
	DB	SYSCALL,.CLOSE	CLOSE SOURCE
	JC	NAMERR		ERROR ON CLOSE
	CALL	REN		REMOVE ENTRY FROM NAMTAB

*	IF DOING INDIVIDUAL FILE COPIES, CLOSE OUTPUT FILE.

	LDA	COPYA
	ANA	A
	JNZ	COPY1		CONCATINATING
	MVI	A,CN.DES
	DB	SYSCALL,.CLOSE	CLOSE DESTINATION
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON CLOSE
	JMP	COPY1		GET NEXT FILE

**	ALL COPIES COMPLETE. CLOSE FILES AND CLEAN UP

COPY5	LDA	COPYC
	ANA	A
	JNZ	COPY6

*	NO FILES COPIED

	CALL	$TYPTX
	DB	BELL,'No Files Copied',ENL
	MVI	A,CN.DES
	DB	SYSCALL,.CLEAR	CLEAR CHANNEL
	RET

COPY6	MVI	B,0		(BC) = COUNT OF FILES COPIED
	MOV	C,A
	LDA	COPYA
	ANA	A
	JZ	COPY7		WILDCARDED
	PUSH	B		SAVE COUNT
	MVI	A,CN.DES
	DB	SYSCALL,.CLOSE	CLOSE DESTINATION
	POP	B		(BC) = FILES COPIED COUNT
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON CLOSE

*	TYPE FILE COUNT

COPY7	LDA	SUPRES
	ANA	A
	RNZ			SUPPRESS TRAIL MESSAGE
	MVI	A,3
	LXI	H,COPYE
	CALL	$UDDN		UNPACK COUNT INTO MESSAGE
	CALL	$TYPTX
	DB	NL
COPYE	DB	'XXX'
	DB	' Files Copied',ENL
	RET

COPYA	DB	0		DESTINATION FILE WILDCARD FLAG (=0 IF WC)
COPYC	DB	0		FILES COPIED COUNT
COPYD	DS	FB.NAML		HOLD AREA FOR WILDCARD DESTINATION
COPYDL	EQU	*-COPYD
	STL	'DISMOU - DISMOUNT CURRENT DISK'
	EJECT
***	MOUNT	-  MOUNT A NEW DISK
*
*	MOUNT MOUNTS A NEW DISK ON THE SPECIFIED UNIT OF THE SELECTED
*	DEVICE.
*
*	DEV:/MOU[NT]
*

MOUNT	EQU	*
	MVI	A,.MOUNT
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	LON	LGCR
	STL	'RESET	 -  RESET CURRENT DISK'
	EJECT
***	DISMOU	-  DISMOUNT CURRENT DISK
*
*	DISMOU DISMOUNTS THE CURRENT DISK ON THE SPECIFIED UNIT OF THE
*	SELECTED DEVICE.
*
*	DEV:/DIS[MOUNT]
*

DISMOU	EQU	*
	MVI	A,.DMOUN
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	LON	LGCR
	EJECT
***	RESET	-  RESET THE CURRENT DISK
*
*	RESET RESETS THE SPECIFIED UNIT OF THE SELECTED DEVICE BY ISSUING
*	THE HDOS RESET CALL, WHICH IN TURN ISSUES A DISMOUNT AND MOUNT
*	ASKING THE USER TO OPEN THE DRIVE IN BETWEEN THE TWO.
*
*	DEV:/RES[ET]
*

RESET	EQU	*
	MVI	A,.RESET
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	SPACE	4,10
**	MDR.	-  MOUNT/DISMOUNT/RESET
*
*	MDR. PERFORMS THE SIMILAR FUNCTIONS OF MOUNT, DISMOUNT, AND RESET.
*
*
*	ENTRY	(A)	=  SYSCALL CODE FOR OPERATION TO BE PERFORMED
*
*	EXIT	IF  NO ERROR
*		    TO CALLER
*		  ELSE
*		    TO ERROR
*
*	USES	ALL
*

MDR.	STA	MDRA		STORE SYSCALL VALUE
	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	STC
	JNZ	ERROR		THERE WAS A TARGET FILE
	LXI	H,LINE
	CALL	$DTB		DELETE TRAILING BLANKS
	CPI	1		(A) = LINE LENGTH INCLUDING <00> BYTE
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JZ	ERROR		NULL DEVICE IS ILLEGAL, ONLY BYTE IS NULL
MDR1	PUSH	H		SAVE SPEC. ADDRESS FOR RETRY
	DB	SYSCALL,0
MDRA	EQU	*-1		SYSCALL VALUE
	POP	H
	RNC			NO ERROR
	PUSH	H		SAVE SPEC. ADDRESS
	CPI	EC.NPM		NO PROVISIONS MADE FOR REMOUNT
	STC
	JNZ	ERROR		ALL ERRORS BUT 'EC.NPM' CONSIDERED FATAL
	MVI	A,OVL0
	DB	SYSCALL,.LOADO	LOAD *HDOSOVL0.SYS*
	JC	ERROR
	MVI	A,OVL1
	DB	SYSCALL,.LOADO	LOAD *HDOSOVL1.SYS*
	JC	ERROR		SYSCALL ERROR
	POP	H		RESTORE SPEC. ADDRESS
	JMP	MDR1		TRY AGAIN
	ELSE
	STL	'MOUNT - MOUNT A DIFFERENT DISK'
	EJECT
MOUNT	SPACE	4,10
***	MOUNT - MOUNT A DIFFERENT DISK.
*
*	MOUNT CAUSES A NEW DISK TO BE MOUNTED.
*
*	INSERT THE DISK IN SY0, THEN TYPE
*
*	/MOUNT



MOUNT	LXI	H,SLABEL						/2.0a/
	MVI	B,0		Count of 256				/2.0a/
	CALL	$ZERO		Zero the old label			/2.0a/

	LXI	D,MOUNTA
	MVI	B,377Q		OFF PERIODS
	CALL	MAD		MOUNT ALTERNATE DISK
	RET

MOUNTA	DB	244Q,306Q,307Q
	DB	NL,'Insert New Disk',':'+200Q
	STL	'ONECOPY - COPY FILES BETWEEN VOLUMES.'
	EJECT
ONECOPY SPACE	4,10
***	ONECOPY - COPY FILES BETWEEN TWO VOLUMES, WITH ONLY ONE
*	DRIVE.
*
*	(AND FOR MY NEXT TRICK...)
*
*	OPECOPY COPIES FILES BETWEEN TWO VOLUMES BY ALTERNATING BETWEEN
*	TWO PHASES, THE READ PHASE AND THE WRITE PHASE.
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED, THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.


COPY	EQU	*		CALLED 'COPY' BY MAINLINE CODE
OCOPY	EQU	*
	CALL	IFL		INITIALIZE  FDN LISTS
	XRA	A
	STA	OCOPYC		CLEAR FILE COUNT
	STA	VOLFLAG		FLAG SOURCE  VOLUME MOUNTED
	LDA	LABEL+LAB.SER	A  = Volume Label			/2.0a/
	STA	VOLSER		SET VOLUME SERIAL NUMBER
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR		ERROR
	STA	OCOPYA		SAVE DESTIONATION TYPE
	CALL	SDD		RESET DEFAULT DEFAULTS
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR
	CALL	$MOVEL
	DW	OCOPYDL
	DW	DESTFB+FB.NAM
	DW	OCOPYD		SAVE WILDCARD DESTINATION
	CALL	EBM		EXPAND BUFFER TO MAX

*	MAKE SURE HE'S NOT TRYING TO CONCATINATE

	LDA	OCOPYA
	ANA	A
	JZ	OCOPY1		HAVE WILDCARDS
	LHLD	NAMTLEN		NO WILDCARDS, ONLY LET HIM SPEFICY ONE SOURCE
	LXI	D,-FB.NAML
	DAD	D
	MOV	A,H
	ORA	L
	MVI	A,PEC.FCI	FILE CONCATINATION IS ILLEGAL
	JNZ	ERROR

*	START READ PHASE

OCOPY1	LDA	BUFPTR+1	(A) = BUFFER FWA/256
	INR	A		ROUND UP TO NEXT PAGE
	STA	OBUFPTR		SET SECTOR BUFFER  FWA/256
	LDA	VOLFLAG
	ANA	A
	JZ	OCOPY2		SOURCE IS MOUNTED
	LXI	D,OCOPYF
	MOV	B,A		(B) = 377Q = PERIODS MASK
	CALL	MAD		MOUNT ALTERNATE DISK
OCOPY2	CALL	RPH		READ PHASE
	LDA	FDNHEAD
	ANA	A
	JZ	OCOPY6		NO FILES ARE READ, ERGO NONE ARE LEFT
	LDA	VOLFLAG
	ANA	A
	JNZ	OCOPY3
	MVI	B,177Q		(B) = PERIODS MASK
	LXI	D,OCOPYG
	CALL	MAD		MOUNT ALTERNATE DISK
OCOPY3	CALL	WPH		WRITE PHASE
	JMP	OCOPY1

*	ALL DONE, FINISH MESSAGE

OCOPY6	LDA	OCOPYC		(A) = FILE COUNT
	MVI	B,0		(BC) = COUNT OF FILES COPIED
	MOV	C,A

*	TYPE FILE COUNT

	MVI	A,3
	LXI	H,OCOPYE
	CALL	$UDDN		UNPACK COUNT INTO MESSAGE
	CALL	$TYPTX
	DB	NL		for aesthetics				/2.0a/
OCOPYE	DB	'XXX'
	DB	' Files Copied',ENL
	RET

OCOPYA	DB	0		DESTINATION FILE WILDCARD FLAG (=0 IF WC)
OCOPYC	DB	0		FILES COPIED COUNT
OCOPYD	DS	FB.NAML		HOLD AREA FOR WILDCARD DESTINATION
OCOPYDL EQU	*-OCOPYD
OCOPYF	DB	244Q,306Q,307Q
	DB	NL,'Insert Source',':'+200Q
OCOPYG	DB	102Q,014Q,44Q
	DB	NL,'Insert Destination',':'+200Q
	STL	'ONECOPY SUBROUTINES'
	EJECT
RPH	SPACE	4,10
**	RPH - READ PHASE.
*
*	RPH  HANDLES THE READ PHASE OF THE COPY PROCESS.
*
*	IT IS ENTERED WITH THE NAMTAB AND FDN TABLE SETUP, AND
*	WITH THE SOURCE DISK MOUNTED.
*
*	READ PHASE:
*
*	DURING THE READ PHASE, THE SOURCE DISK IS MOUNTED. SOURCE FILES ARE
*	OPENED IN THE ORDER OF THEIR APPEARANCE. FOR EACH OPENED
*	FILE, A 'FILE DESCRIPTOR NODE' *FDN* IS ADDED  TO  THE ACTIVE
*	CHAIN. THEN, AS MUCH AS THE FILE AS POSSIBLE IS READ INTO MEMORY.
*
*	THE PROCESS CONTINUES UNTIL
*		1) THERE IS NO MORE FREE RAM
*		2) OR, THERE ARE NO MORE FILE DESCRIPTOR NODES IN THE FREE CHAIN
*		3) OR, THERE ARE NO MORE FILES IN NAMTAB (INPUT FILE LIST)
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


RPH	EQU	*


*	SEE IF ANY MEMORY TO HAVE

	CALL	CBR		COMPUTE BUFFER ROOM
	RZ			NONE

*	SEE IF WE NEED TO READ SOME MORE INTO A PART-COPIED FILE

	LXI	H,FDNHEAD
	MOV	L,M		(HL) = ADDRESS IF FIRST NODE
	MOV	A,L
	ANA	A
	JZ	RPH1		IS NO FIRST NODE, ERGO NO FILE
	INX	H
	ERRNZ	FDN.STA-1
	MOV	A,M		(A) = .STA
	ANI	ST.OPR
	LXI	D,NAMTAB
	JNZ	RPH2.5		FILE IS INCOMPLETELY READ

*	SEE IF ANY FREE FILE DESCRIPTOR NODES TO USE

RPH1	LDA	FDNFRE
	ANA	A
	RZ			NO MORE

*	SEE IF THERE IS A FILE IN NAMTAB WITHOUT AN ENTRY IN FNDLIST.
*	SINCE THE FIRST ENTRY IN FDNLIST CORRESPONDS TO THE FIRST IN
*	NAMTAB, ETC., WE'LL JUST RUN DOWN FDNLIST UNTIL THE END, AND
*	THE NEXT NAMTAB FILE WILL BE THE ONE WE WANT...

	LXI	B,FB.NAML	(BC) = ENTRY SIZE IN NAMTAB
	LXI	D,-FB.NAML		(DE) = POINTER INTO NAMTAB
	LXI	H,FDNHEAD
	MOV	A,L		START WITH FDNHEAD
RPH2	MOV	L,A		FOLLOW LINK
	MOV	A,M		(A) = NEXT NODE
	XCHG
	DAD	B		ADVANCE POINTER INTO NAMTAB
	XCHG
	ANA	A
	JNZ	RPH2		LINK SOME MORE
	PUSH	H		(HL) = ADDRESS OF LAST NODE
	LHLD	NAMTLEN
	CALL	$CDEHL		SEE IF HAVE ACCOUNTED FOR ALL NAMTAB ENTRYS
	POP	H
	RE			FILES ALL USED UP

*	HAVE ROOM FOR DATA, HAVE A NODE FOR THE FILE COUNTS, AND
*	HAVE A FILE NAME. ALL SET FOR BUSINESS..
*
*	(DE) = INDEX INTO NAMTAB FOR FILE
*	(HL) = NODE ADDRESS OF LAST ENTRY IN LIST
*
*	CHAIN THE FIRST FREE NODE ONTO THE END OF THE LIST

	LDA	FDNFRE
	MOV	M,A		CHAIN TO  NEW END  NODE
	MOV	L,A
	MOV	A,M		(A) =  NEXT NODE IN FREE CHAIN
	STA	FDNFRE
	MVI	B,FDNELEN
	PUSH	H		SAVE NODE ADDRESS
	CALL	$ZERO		ZERO ENTIRE NODE, ENCLUDING CHAIN (AT END,  NOW)
	LXI	B,NAMTAB
	XCHG
	DAD	B		(HL) = ADDRESS OF NAMTAB ENTRY
	SHLD	NAMTPTR		POINTER TO CURRENT NAMTAB ENTRY
	XCHG
	POP	H
	ERRNZ	FDN.STA-1
	INX	H		(HL) = ADDR OF FDN.STA OF NODE

*	READY TO OPEN FILE
*
*	(DE) = NAMTAB ENTRY ADDRESS
*	(HL) = #FDN.STA OF ENTRY

RPH2.5	PUSH	H		SAVE ADDRESS
	XCHG
	XRA	A
	ERRNZ	CN.SOU		(A) = SOURCE CHANNEL NUMBER
	DB	SYSCALL,.OPENR	OPEN
	JC	NAMERR		ERROR
	POP	D
	LDAX	D		(A) = FDN.STA
	ANI	ST.OPR
	PUSH	D		SAVE ADDRESS
	JNZ	RPH3		ALREADY OPENED IN PREVIOUS PASSES

*	FIRST TIME THIS FILE HAS BEEN OPENED. SEE IF CONTIGUOUS

	PUSH	H
	LXI	H,OCOPYC
	INR	M
	POP	H
	LDAX	D
	ORI	ST.OPR		SET OPEN FOR READ
	STAX	D
	LHLD	S.CFWA		(HL) = CHANNEL 0 FWA
	ERRNZ	IOCCTD-1	WE NEED TO CHAIN ONE TO GET TO USER #0
	CALL	$HLIHL
	ERRNZ	CN.SOU		ASSUME WE WANT CHANNEL 0
	CALL	$INDL
	DW	IOC.DIR+DIR.FLG
	MOV	A,E		(A) = DIR.FLG
	ANI	0 DIF.CNT	* * PATCH * *
	JZ	RPH3		NOT CONTIG

*	IS CONTIG. GET FILE SIZE

	CALL	$INDL
	DW	IOC.GRT
	PUSH	D		SAVE GRT ADDRESS
	CALL	$INDL
	DW	IOC.DIR+DIR.FGN (E) = DIR.FGN
	MOV	A,E
	POP	H		(HL) = GRT TABLE ADDRESS
	CALL	CFS.		COMPUTE BLOCK SIZE
	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H
	MOV	A,M		(A) = FDN.STA
	ORI	ST.CNT		FLAG CONTIG
	MOV	M,A
	INX	H
	ERRNZ	FDN.SIZ-FDN.STA-1
	MOV	M,E		SET BLOCK COUNT

*	READY TO READ DATA. POSITION FILE (IN CASE SOME WAS READ IN
*	PREVIOUS PASSES) AND COMPUTE THE MAX POSSIBLE READ COUNT
*
*	((SP)) = ADDRESS OF FDN.STA FOR NODE

RPH3	POP	H		(HL) = ADDRESS OF FDN.STA
	PUSH	H
	CALL	$INDL
	DW	FDN.AMR-FDN.STA (DE) - AMOUNT READ (IN SECTORS)
	MOV	B,D
	MOV	C,E		(BC) = AMOUNT READ
	MVI	A,CN.SOU
	DB	SYSCALL,.POSIT		POSIT
	JC	IERR3		POSIT BLEW UP
	CALL	CBR		COMPUTE BUFFER ROOM
	XCHG			(D) = POINTER/256, (E) = LIMIT/256
	POP	H		(HL) = #FDN.STA
	LXI	B,FDN.ADR-FDN.STA
	DAD	B		(HL) = #FDN.ADR
	MOV	M,D		SET ADDRESS/256
	PUSH	H		SAVE #FDN.ADR
	MVI	E,0		(DE) = ADDRESS
	MOV	B,A		(B) = SECTORS OF RAM AVAILABLE
	MOV	C,E		(C) = 0
	PUSH	B		SAVE TRY COUNT
	MVI	A,CN.SOU
	DB	SYSCALL,.READ	READ THE STUFF

*	COMPUTE THE AMOUNT READ (IN CASE OF EOF)

	POP	D		(DE) = TRY COUNT
	JNC	RPH4		GOT  ALL WE TRYED
	CPI	EC.EOF
	JNE	NAMERR		NOT JUST EOF, GOT TROUBLES
	MOV	A,D
	SUB	B		REMOVE AMOUNT WE DIDNT GET
	MOV	D,A
	POP	H		(HL) = #FDN.ADR
	PUSH	H
	LXI	B,FDN.STA-FDN.ADR
	DAD	B
	MOV	A,M		(A) = FDN.STA
	ANI	377Q-ST.OPR	EOF, NOT OPEN FOR READ ANYMORE
	MOV	M,A		POST READ COMPLETE FOR THIS GUY

*	STORE RESULTS OF READ IN NODE
*
*	(D) = SECTORS READ
*	((SP)) = #FDN.ADR

RPH4	POP	H		(HL) = #FDN.ADR
	INX	H
	ERRNZ	FDN.AIM-FDN.ADR-1	(HL) = ADDRESS IF AMOUNT IN MEMORY BYTE
	MOV	M,D		STORE SECTORS IN MEMORY COUNT
	LXI	B,FDN.AMR-FDN.AIM
	DAD	B		(HL) = #FDN.AMR (AMOUNT READ)
	MOV	A,M		(A) = AMOUNT READ BEFORE
	ADD	D		ADD NEW AMOUNT
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		PROPIGATE FOR VERY LARGE FILES
	MOV	M,A
	LXI	H,OBUFPTR
	MOV	A,M
	ADD	D		ADVANCE FREE RAM POINTER BY AMOUNT READ
	MOV	M,A
	MVI	A,CN.SOU
	DB	SYSCALL,.CLOSE	CLOSE FILE
	JMP	RPH		SEE IF MORE TO READ
WPH	SPACE	4,10
**	WPH - WRITE PHASE.
*
*	WPH HANDLES THE WRITE PHASE PROCESSING. IT IS ENTERED WITH
*	THE FDN CHAIN SETUP, THE NAMTAB SETUP, AND
*	THE DESTINATION DISK MOUNTED.
*
*
*	WRITE PHASE
*
*	DURING THE WRITE PHASE, THE DESTINATION DISK IS MOUNTED. THE NODES
*	ARE TAKEN FROM THE ACTIVE CHAIN, AND PROCESSED. IF THE FILE HAD
*	BEEN PARTIALLY WRITTEN THE LAST PASS, IT IS  RE-OPENED AND POSITIONED.
*	IF THERE IS NOT MORE DATA TO READ FOR A PROCESSED
*	NODE, IT IS REMOVED, AND THE CORRESPONDING ENTRY IN NAMTAB IS DELETED.
*
*	WRITE PHASE CONTINUES UNTIL
*
*		1) THERE ARE NO MORE FILE NODES IN THE ACTIVE LIST
*		2) OR, THE FIRST (AND ONLY) ENTRY IN THE LIST HAS NO
*		   MORE DATA IN MEMORY, BUT HAS NOT BEEN COMPLETELY READ.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


WPH	EQU	*

*	SEE IF MORE TO WRITE

	LXI	H,FDNHEAD
	MOV	L,M
	MOV	A,L		(A) = FIRST NODE INDEX
	ANA	A
	RZ			NO MORE
	CALL	$INDL
	DW	FDN.AIM		(E) = AMOUNT IN MEMORY FOR THIS GUY
	MOV	A,E
	ANA	A
	JNZ	WPH0		GOT DATA

*	NO DATA IN NODE. IF STILL READING, RETURN FOR MORE

	INX	H
	MOV	A,M
	DCX	H
	ANI	ST.OPR
	RNZ			STILL READING, GET MORE
	XCHG			(DE) = ADDRESS
	JMP	WPH4		REMOVE NODE, AM DONE WITH FILE

*	HAVE DATA TO WRITE. SEE IF WE HAVE OPENED THIS FILE BEFORE.,
*	OR IF THIS IS THE FIRST TIME

WPH0	PUSH	H		SAVE NODE POINTER
	INX	H
	ERRNZ	FDN.STA-1
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPW
	JNZ	WPH2		OPENED BEFORE
	ERRNZ	ST.OPW-1
	INR	M		SET '1' BIT

*	BUILD NAME INTO DESTFB

	PUSH	H		SAVE NODE ADDRESS
	LXI	B,OCOPYD
	LXI	D,NAMTAB
	LXI	H,DESTFB+FB.NAM
	CALL	MWN		MERGE WILDCARD NAME
	POP	H

*	IS 1ST TIME FOR THIS FILE. IF CONTIGUOUS FLAG, OPEN THE FILE
*	FOR CONTIGUOUS

	MOV	A,M		(A) = FLAG BYTE
	ANI	ST.CNT
	JNZ	WPH1		IS CONTIG
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	DB	SYSCALL,.OPENW	JUST OPEN FOR WRITE
	JC	DESTERR		ERROR
	JMP	WPH3		WRITE THE DATA

*	IS CONTIG FILE. OPEN IN CONTIG MODE

WPH1	INX	H
	ERRNZ	FDN.SIZ-FDN.STA-1
	MOV	C,M		(C) = COUNT (IN BLOCKS)
	MVI	B,0
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	PUSH	B		SAVE COUNT
	DB	SYSCALL,.DELET	DELETE OLD ONE
	JNC	WPH1.5		DELETED
	CPI	EC.FNF
	JNE	ERROR		MUST BE WRITE PROTECTED, OR  SOMETHING...
WPH1.5	POP	B		(BC) = COUNT
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	DB	SYSCALL,.OPENC	OPEN CONTIG
	JC	DESTERR
	JMP	WPH3

*	THIS FILE HAS ALREADY BEEN PARTIALLY WRITTEN. OPEN IN UPDATE MODE
*	SO WE CAN EXTEND IT.

WPH2	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES
	DB	SYSCALL,.OPENU	OPEN FOR UPDATE
	JC	DESTERR		PROBLEMS
	POP	H
	PUSH	H		(HL) = #FDN.STA
	CALL	$INDL
	DW	FDN.AMW		(DE) = AMOUNT WRITTEN
	MOV	B,D
	MOV	C,E		(BC) = SECTORS WRITTEN
	MVI	A,CN.DES
	DB	SYSCALL,.POSIT	POSITION FOR EXTEND
	JC	IERR1		COULDNT GET THERE!

*	FILE OPEN AND POSITIONED. WRITE DATA

WPH3	POP	H
	PUSH	H		(HL) = #FDN.LNK
	CALL	$INDL
	DW	FDN.ADR		(E) = ADDR/256, (D) = CNT/256
	MOV	B,D
	MOV	D,E
	MVI	E,0		(DE) = ADDRESS
	MOV	C,E		(BC) = COUNT
	MVI	A,CN.DES
	PUSH	B		SAVE WRITE COUNT
	DB	SYSCALL,.WRITE	WRITE IT
	JC	DESTERR		PROBABLY OUT OF ROOM
	MVI	A,CN.DES
	DB	SYSCALL,.CLOSE	CLOSE IT
	JC	DESTERR
	POP	B		(B) = SECTORS WRITTEN
	POP	H
	PUSH	H		(HL) = #FDN.LNK
	LXI	D,FDN.AMW-FDN.LNK
	DAD	D		(HL) = FDN.AMW
	MOV	A,M
	ADD	B
	MOV	M,A
	INX	H
	MOV	A,M
	ACI	0		INCREMENT AMOUNT WRITTEN
	MOV	M,A

*	CLEAR 'IN MEMORY' COUNT IN NODE. IF THE FILE HAS NO MORE TO
*	READ, REMOVE IT FROM THE CHAIN AND NAMTAB

	POP	D		(DE) = FDN.LNK
WPH4	LXI	H,FDN.AIM
	DAD	D
	MVI	M,0		CLEAR AMOUNT IN MEMORY
	XCHG			(HL) = FDN.LNK
	INX	H
	ERRNZ	FDN.STA-FDN.LNK-1
	MOV	A,M		(A) = FDN.STA
	ANI	ST.OPR
	RNZ			STILL READING, AM DONE FOR THIS PHASE

*	UNLINK NODE FROM LIST

	DCX	H
	MOV	A,M
	STA	FDNHEAD		UNLINK FROM ACTIVE LIST
	LDA	FDNFRE
	MOV	M,A		PUT THIS GUY ON HEAD OF FREE LIST
	MOV	A,L
	STA	FDNFRE
	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	WPH		TRY TO WRITE THE NEXT GUY
CBR	SPACE	4,10
**	CBR - COMPUTE BUFFER ROOM.
*
*	CBR COMPUTES THE NUMBER OF SECTORS WORTH OF RAM
*	STILL FREE.
*
*	ENTRY	NONE
*	EXIT	(A) = SECTORS OF RAM FREE
*		'Z' SET IFF (A)	 = 0
*		(H) = BUFPTR/256
*		(L) = OBUFLIM/256
*	USES	A,F


CBR	LHLD	OBUFLIM
	ERRNZ	OBUFPTR-OBUFLIM-1
	MOV	A,L
	SUB	H
	RET
IFL	SPACE	4,10
**	IFL - INITIALIZE FDN LIST.
*
*	IFL CHAINS ALL THE FDN NODES TO THE FREE LIST. THIS
*	CLEANUP IS NECESSARY IN CASE A CTL-C OR SOMETHING
*	LEFT THE LIST GARBAGED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


IFL	LXI	H,FDN.1
	MOV	A,L		(A) = FIRST LINK
	STA	FDNFRE
	XRA	A
	STA	FDNHEAD		NONE IN LIST
	MVI	B,FDNCNT-1	(B) = NUMBER OF NODES-1
IFL1	MVI	A,FDNELEN
	ADD	L		(A) = #ADDR OF NEXT NODE
	MOV	M,A		SET LINK
	MOV	L,A		FORWARD TO NEXT LINK
	DCR	B
	JNZ	IFL1		MORE TO GO
	MVI	M,0		LAST ONE CHAINS NOWHERE
	RET
MAD	SPACE	4,10
**	MAD - MOUNT ALTERNATE DISK.
*
*	MAD DISMOUNTES THE CURRENT DISK, HAS THE USER INSERT THE
*	OTHER DISK, AND MOUNTS IT.
*
*	ENTRY	(B) = FRONT PANEL LED PATTERN
*		(DE) = PROMPT PATTERNS FOR PANEL AND CONSOLE
*	EXIT	(HL) = #VOLFLAG
*	USES	ALL


MAD	EQU	*

*	DISMOUNT CURRENT DISK

	PUSH	D
	PUSH	B		SAVE ENTRY PARAMETERS IN CASE OF RETRY
	PUSH	D
	PUSH	B		SAVE ENTRY PARAMETERS OVER SYDD CALL
	LXI	H,MNDA		DEVICE SPECIFICATION
	DB	SYSCALL,.DMNMS	DISMOUNT WITHOUT MESSAGE
	JC	ERROR		IF ERROR

*	SETUP PROMPT ON FP LEDS AND CONSOLE FOR NEW DISK

MAD0	MVI	A,UO.DDU+UO.CLK+UO.HLT					/2.0a/
	STA	.MFLAG		HALT DISPLAY UPDATE

	LXI	H,.ALEDS
	MVI	A,9
	POP	B		(B) = PERIOD PATTERN
MAD2	MOV	M,B		SET PATTERN
	INX	H
	DCR	A
	JNZ	MAD2		IF MORE TO BLANK

	LXI	H,.ALEDS+3
	LXI	B,3
	POP	D		(DE) = PROMPT LIST
	CALL	$MOVE		MOVE IN PROMPT PATTERN

	XCHG			(HL) = PATTERN
	DB	SYSCALL,.PRINT	CONSOLE PROMPT
	CALL	$TYPTX
	DB	BELL+200Q	BEEP CONSOLE, TOO
	MVI	A,100
	CALL	.HORN		BEEP A WARNING

*	WAIT FOR SIGNAL THAT NEW DISK IS IN

MAD3	MVI	A,DC.RDY						/2.0a/
	CALL	SYDD							/2.0a/
	JNC	MAD3		Wait for device to go non-ready		/2.0a/

MAD4	MVI	A,DC.RDY						/2.0a/
	CALL	SYDD							/2.0a/
	JC	MAD4		Wait for device to go ready		/2.0a/

*	READ NEW DISK'S LABEL

	CALL	GETLAB
	JC	ERROR

*	SEE IF LABEL CHANGED FROM BEFORE

	MVI	C,0		Compare 256				/2.0a/
	LXI	D,SLABEL	DE = address of last label		/2.0a/
	LXI	H,LABEL		HL = Address of current label		/2.0a/
	CALL	$COMP		See if the label changed		/2.0a/
	POP	B
	POP	D		RESTORE ENTRY PARAMETERS

	LXI	H,VOLSER
	LDA	LABEL+LAB.SER
	JNE	MAD4.5		IS THE RIGHT DISK			/2.0a/
	PUSH	D		SAVE PARAMS AS IN BEGINNING
	PUSH	B
	PUSH	D		SAVE FOR RETRY
	PUSH	B
	JMP	MAD0		IT WAS NOT THE RIGHT DISK

MAD4.5	MOV	M,A		SET NEW SERIAL
	LXI	H,VOLFLAG
	MOV	A,M
	CMA
	MOV	M,A		COMPLEMENT VOLUME FLAG

*	ERASE FRONT PANEL DISLPLAY

	LXI	H,.ALEDS
	MVI	A,9
MAD5	MOV	M,B		SET TO PATTERN
	INX	H
	DCR	A
	JNZ	MAD5

	LXI	B,256							/2.0a/
	LXI	D,LABEL							/2.0a/
	LXI	H,SLABEL						/2.0a/
	CALL	$MOVE		Save Current Label			/2.0a/

	CALL	MND		MOUNT NEW DISK
	CALL	$TYPTX		Show user that disk is OK		/2.0a/
	DB	ENL							/2.0a/
	RET
MND	SPACE	4,10
**	MND	- MOUNT NEW DISK
*
*	MOUNT NEW DISK ONTO DEVICE SSECIFIED IN MNDA
*
*
*	ENTRY	NONE
*
*	EXIT	LABEL	= LABEL SECTOR
*
*	USES	ALL
*

MND	LXI	H,MNDA
	DB	SYSCALL,.MONMS	MOUNT WITHOUT MESSAGE
	JC	ERROR		IF ERROR IN MOUNT
	RET								/2.0a/

MNDA	DB	'SY0:',0
GETLAB	SPACE	4,10
**	GETLAB	- GET LABEL
*
*	GETLAB READS THE DISK LABEL
*
*	NOTE:	This routine leaves the Volume mounted as		/2.0./
*		zero.
*
*	ENTRY	NONE
*
*	EXIT	LABEL IN LABEL
*		(PSW)	= 'C' CLEAR IF NO ERROR
*			= 'C' SET   IF	  ERROR
*			   (A)	= ERROR CODE
*
*	USES	ALL
*

GETLAB	LXI	H,0							/2.0a/
	MVI	A,DC.MOU						/2.0a/
	CALL	SYDD		Mount the Disk as volume 0		/2.0a/
	RC			Some type of problem			/2.0a/

	LXI	H,DDF.LAB
	LXI	D,LABEL
	LXI	B,256
	MVI	A,DC.RER						/2.0a/
	CALL	SYDD
	RET
	ENDIF
	STL	'RENAME - PROCESS RENAME COMMAND'
	EJECT
***	DELETE - PROCESS DELETE COMMAND.
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/DELETE
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	IF *.* IS SPECIFIED, DELETE ASKS,
*		DELETE ALL ?!? ARE YOU SURE?


	IF	.PIP.
DELETE	EQU	*
	LXI	H,LINE

*	SEE IF A DESTINATION FILE SPECIFIED

DEL1	MOV	A,M
	INX	H
	ANA	A
	JZ	DEL2		END OF LINE
	CPI	'='
	JNE	DEL1

*	HE SPECIFIED A DESTINATION FILE

	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	JMP	ERROR		FORMAT ERROR

*	NO TARGET FILE SPECIFIED

DEL2	MVI	A,1		CHECK FOR *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR		NO GOOD

*	DELETE FILES ONE BY ONE

DEL5	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	RZ			END OF LIST
	LXI	H,NAMTAB
	DB	SYSCALL,.DELET	REMOVE IT
	JC	NAMERR		ERROR ON DELETE
	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	DEL5		DELETE THE NEXT ONE
	STL	'RENAME - PROCESS RENAME COMMAND'
	EJECT
***	RENAME - RENAME FILES.
*
*	SYNTAX:
*
*	DEST = SOURCE1,...,SOURCEN
*
*	RENAME IS PROCESSED IN A MANNER SIMILAR TO COPY, EXCEPT THAT THE
*	FILE IS RENAMED, RATHER THAN COPIED.


RENAME	EQU	*
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCEFILE LIST
	JC	ERROR

*	DO MULTIPLE RENAMES

REN1	LXI	B,DESTFB+FB.NAM (BC) = WILDCARDED TARGET NAME
	LXI	D,NAMTAB	(DE) = NORMAL SOURCE NAME
	LXI	H,RENA		(HL) = BUFFER FOR RESULT NAME
	PUSH	B		SAVE #DESTFB+FB.NAM
	PUSH	D		SAVE #NAMTAB
	CALL	MWN		MERGE WILDCARD NAME
	POP	D		(DE) = #NAMTAB
	POP	H		(HL) = #DESTFB+FB.NAM


*	SEE IF SOURCE AND DEST FILE ON SAME DEVICE

	PUSH	D		SAVE #NAMTAB (SOURCE NAME)
	MVI	C,3
	CALL	$COMP		COMPARE DEVICES
	MVI	A,PEC.DNC	DEVICES NOT CONSISTANT
	JNE	ERROR

*	SEE IF TARGET ALREADY EXISTS

	LXI	H,RENA
	MVI	A,CN.SOU
	DB	SYSCALL,.OPENR
	LXI	H,RENA-FB.NAM
	JC	REN2		HAVE AN ERROR (AS WE SHOULD)
	MVI	A,EC.FAP	FILE AALREADY PRESENT
	JMP	$FERROR		ALREADY THERE

REN2	CPI	EC.FNF		MUST BE NOT FOUND
	JNE	$FERROR		OTHER ERROR
	POP	H		(HL) = SOURCE NAME
	LXI	B,RENA		(BC) = NEW (TARGET) NAME
	DB	SYSCALL,.RENAM	RENAME IT
	JC	NAMERR		ERROR ON RENAME

*	REMOVE NAME FROM NAMTAB

	CALL	REN		REMOVE ENTRY FROM NAMTAB
	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JNZ	REN1
	RET

RENA	DS	FB.NAML		FILE NAME WORK AREA
	ENDIF
	STL	'LIST - LIST DIRECTORY CONTENTS'
	EJECT
***	LIST - INDEX DIRECTORY.
*
*	DEST=SOURCE/LIST
*		   /BRIEF
*
*	THESE SWITCHES CAUSE THE DIRECTORY CONTENTS OF THE SPECIFIED FILE(S)
*	TO BE LISTED
*
*	IN /LI FIRM, THE OUTPUT IS:
*
*	NAME	EXT	SIZE	  DATE		FLAGS
*	XXX	.XXX	 NNN	DD-MMM-YY	CWS
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*		NNN FILES USING MMM SECTORS, XXX FREE
*
*	IN /BR FORM, ONLY THE NAME AND EXTENSION ARE LISTED,
*	4 ACROSS THE PAGE.
*
*	SPECIAL CONSIDERATIONS:
*
*	A NULL NAME OR EXTENSION IS TAKEN AS '*' (WILDCARD)
*
*	IMPLIMENTATION:
*
*	A FILE LIST OF SOURCE FILES IS BUILT. THE DEVICE DIRECTORY FILE
*	IS THEN READ, AND EACH FILE IN IT IS CHECKED FOR A MATCH
*	AGAINST ANY SOURCE SPECIFICATIONS. ELIGIBLE FILES ARE LISTED.


LIST	LXI	H,0
	JMP	LIST1

BRIEF	LXI	H,1
*	JMP	LIST1

LIST1	SHLD	LSTA		(LSTA) = 0 IF LIST, 1 IF /BRIEF
	ERRNZ	LSTB-LSTA-1	LSTB   FILE COUNT
	LXI	H,0
	SHLD	LSTC		CLEAR SECTORS USED COUNT
	CALL	$MOVEL
	DW	9,S.DATE,LSTG1	SET DATE IN HEADING

*	CRACK DESTINATION FILE NAMES

	IF	.PIP.
	CALL	DDF		DECODE DEST FILE NAME
	JC	ERROR		FILE NAME ERROR
	ANA	A
	MVI	A,PEC.IUW	ILLEGAL USE OF WILDCARD IN DEST
	JZ	ERROR
	ENDIF

*	BUILD LIST OF SPECIFICATIONS

	CALL	BLS		BUILD LIST OF SOURCE SPECS
	JC	ERROR		ERROR IN LIST
	LXI	B,3
	LXI	H,DIRNAM
	CALL	$MOVE		MOVE DEVICE CODE INTO DIRECT.SYS NAME
	LXI	H,DIRNAM+2
	MOV	A,M		SEE IF UNIT NUMBER OMITTED
	ANA	A
	JNZ	LIST1.5		SPECIFIED
	MVI	M,'0'		DONT ALLOW NULL NUMBER

*	GET ADDRESS OF DEVICE'S GRT

LIST1.5 LXI	H,DIRNAM	(HL) = # OF XXX:DIRECT.SYS (XXX = DEVICE)
	LXI	B,LSTD		(BC) = ADDRESS FOR RETURN INFO
	DB	SYSCALL,.DECODE		DECODE NAME
	JC	ERROR		UNKNOWN DEVICE
	LDA	LSTD+0
	ANI	DT.DD
	MVI	A,EC.DNS
	JZ	ERROR		NOT DIRECTORY DEVICE
	LHLD	LSTD+17		(HL) = DEV TBL ADDR		/80.04.gc/

	LXI	D,DEV.UNT					/80.04.gc
	DAD	D
	LDA	LSTD+3
	CALL	S.GUP		HL = UNIT TABLE POINTER

	CALL	$INDLB						/80.04.gc/
	DW	UNT.SPG						/80.04.gc/
	STA	LSTF		SAVE  SECTORS PER GROUP		/80.04.gc/

	CALL	$INDL
	DW	UNT.GRT
	XCHG
	SHLD	LSTE		SAVE  GRT ADDRESS
	XCHG

*	OPEN DEVICE'S DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	DB	SYSCALL,.OPENR
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JC	ERROR		CANT OPEN DIRECTORY


*	OPEN OUTPUT FILE

	IF	.PIP.
	LXI	H,DESTFB
	CALL	$FOPEW		OPEN FOR WRITE
	ENDIF

*	GENERATE HEADING

	LXI	B,1		(BC) = TEXT COUNT
	LXI	D,LSTG		(DE) = TEXT ADDRESS
	LDA	LSTA
	ANA	A
	JNZ	LIST2		IS SHORT
	MVI	C,LSTGL		PRINT FULL HEADING
	IF	.PIP.
LIST2	CALL	$FWRIB		WRITE HEADING
	ELSE
LIST2	MOV	A,C
	XCHG			(HL) = LINE ADDRESS
	CALL	$TYPCC		PRINT ON CONSOLE
	ENDIF

*	READ DIRECTORY BLOCKS, LOOKING FOR FILE MATCHES

LIST3	LXI	B,512
	CALL	GDWP		DE = DIRECTORY WORKSPACE POINTER  /79.11.GC/
	MVI	A,CN.DIR
	PUSH	D						/79.11.GC/
	DB	SYSCALL,.READ
	POP	D		DE = DIRECOTRY WORKSPACE	/79.11.GC/
	JC	LIST9		ALL DONE

*	CHECK NEXT ENTRY IN NAMTAB AGAINST DIRECTORY ENTRY.
*	(DE) = DIRECTORY BUFFER POINTER

LIST4	LDAX	D		(A) = FIRST CHARACTER OF NAME
	ANA	A
	JZ	LIST3		END OF THIS BUFFER
	INR	A
	ERRNZ	DF.EMP-377Q
	JZ	LIST7		THIS ENTRY IS EMPTY
	INR	A
	JZ	LIST9		NO MORE ENTRYS IN DIRECTORY
	XCHG
	CALL	CFE		CHECK FILE ELIGIBILITY
	XCHG
	JNE	LIST7		NOT ELIGIBLE
	LXI	H,NAMTAB

LIST5	PUSH	H
	PUSH	D		SAVE ADDRESS OF FILE AND PATTERN
	CALL	CAD		CONVERT ASCII NAMTAB ENTRY TO DIRECTORY FORMAT
	LXI	D,PIO.DIR+DIR.NAM	(DE) = NAMTAB PATTERN
	POP	H
	PUSH	H		(HL) = DIRECTORY PATTERN
	MVI	B,8+3		CHECK FOR MATCH
	CALL	CWM		CHECK FOR WILDCARD MATCH
LIST6	POP	D
	POP	H
	JE	LIST8		GOT FILE TO LIST
	LXI	B,FB.NAML
	DAD	B		ADVANCE PAST ENTRY IN NAMTAB

*	SEE IF AT END OF NAMTAB

	PUSH	D
	XCHG			(DE) = NEW ADDRESS
	LHLD	NAMTLEN
	LXI	B,NAMTAB
	DAD	B		(HL) = LWA+1 OF TABLE
	XCHG
	CALL	$CDEHL		COMPARE
	POP	D
	JNE	LIST5		MORE IN TABLE

*	FILE DOESNT MATCH ANY SELECTED FILE. PASS TO NEXT ONE

LIST7	XCHG			(HL) = DIR BUFFER ADDRESS

	PUSH	H						/79.11.GC/
	CALL	GDWP.		HL = DIRECTORY WORKSPACE PTR.	/79.11.GC/
	CALL	$INDLB		A  = DIR. ENTRY LENGTH		/79.11.GC/
	DW	DIS.ENL						/79.11.GC/
	POP	H						/79.11.GC/

	CALL	$DADA.		ADVANCE
	MOV	A,M
	ANA	A
	XCHG
	JNZ	LIST4		TRY THIS ONE
	JMP	LIST3		READ ANOTHER BLOCK

*	HAVE FILE TO LIST

LIST8	PUSH	D		SAVE DIR POINTER
	LDA	LSTF		(A) = SECTORS PER GROUP THIS DEVICE
	CALL	PFI		PRINT FILE INFO
	POP	D
	LXI	H,LSTB
	INR	M		COUNT FILE
	JMP	LIST7		ADVANCE TO NEXT FILE

*	ALL DONE. CLOSE DIRECTORY FILE

LIST9	MVI	A,CN.DIR
	DB	SYSCALL,.CLOSE	CLOSE FILE
	LXI	B,1		ASSUME SHOFT FORM, JUST WRITE NL
	LDA	LSTA		(A) = FORM FLAG
	ANA	A
	JNZ	LIST10		IS SHORT, NO TRAILER

*	PRINT SUMMARY:
*
*	NNN FILES, USING XXX SECTORS. YYY FREE

	LDA	LSTB
	MOV	C,A
	MVI	B,0		(BC) = FILE COUNT
	MVI	A,3
	LXI	H,LSTH1
	CALL	$UDDN		FILE COUNT

	LHLD	LSTC
	MOV	B,H
	MOV	C,L		(BC) = SECTOR COUNT
	LXI	H,LSTH2
	MVI	A,4						/80.05.gc/
	CALL	$UDDN		USED COUNT

	LHLD	LSTE
	MOV	A,M
	CALL	CFS		FOLLOW GRT CHAIN
	LDA	LSTF
	CALL	$MU86		(HL) = SECTORS FREE
	MOV	B,H
	MOV	C,L
	LXI	H,LSTH3
	MVI	A,4						/80.05.gc/
	CALL	$UDDN		UNPACK FREE

	LXI	B,LSTHL
LIST10	LXI	D,LSTH
	LDA	SUPRES
	ANA	A
	IF	.PIP.
	LXI	H,DESTFB
	JNZ	$FCLO		CLOSE AND EXIT, SUMMARY SUPPRESSED
	CALL	$FWRIB		WRITE TRAILER

*	ALL DONE. CLOSE OUTPUT FILE

	JMP	$FCLO		CLOSE AND EXIT
	ELSE
	RNZ			NOT TO SUMMARYIZE
	MOV	A,C		(A) = COUNT
	XCHG			(HL) = ADDRESS
	JMP	$TYPCC		TYPE TEXT AND EXIT
	ENDIF

LSTA	DB	0		<>0 IFF SHORT FORM

LSTB	DB	0		FILE COUNT
LSTC	DW	0		SECTORS USED
LSTD	DS	24		FILE NAME DECODE AREA
LSTE	DW	0		GRT ADDRESS
LSTF	DB	0		SECTORS PER GROUP FOR THIS DEVICE
LSTG	DB	NL,'Name',TAB,'.Ext',TAB,'Size',TAB,'  Date',TAB,TAB,'Flags',TAB
LSTG1	DS	9		DATE
	DB	NL,NL
LSTGL	EQU	*-LSTG

LSTH	DB	NL,'   '		FIRST CHARACTER MUST BE <NL>
LSTH1	DB	'NNN Files, Using '
LSTH2	DB	'MMMM Sectors ('
LSTH3	DB	'XXXX Free)',NL
LSTHL	EQU	*-LSTH
	SPACE	4,10
**	BLS - BUILD LIST OF SOURCE FILES.
*
*	BLS BUILDS A LIST OF SOURCE FILES INTO *NAMTAB*
*	NULL FIELDS ARE SET TO WILDCARDS. BLS REQUIRES THAT ALL
*	FILES SPECIFIED HAVE THE SAME DEVICE.
*
*	IF THE COMMAND LINE CONTAINS NO FILES. BUT CONTAINS AT LEAST
*	ONE BLANK (AS WOULD BE THE CASE IN PROCESSING THE /LIST SWITCH, SINCE
*	THE '/LIST' IS REPLACED WITH BLANKS) A FILE NAME OF ????????.???
*	IS DECODED.
*	ENTRY	NAMTAB EMPTY
*	EXIT	'C' CLEAR IF OK
*		(DE) = #BLSA = 3 CHARACTER DEVICE NAME
*		'C' SET IF ERROR
*		 (A) = ERROR MESSAGE
*	USES	ALL


BLS	CALL	$MOVEL
	DW	3,BLSC,BLSA	SET INITIAL DEFAULT DEVICE
	LXI	H,0
	SHLD	NAMTLEN		CLEAR NAMTAB
	MVI	A,377Q
	STA	BLSB		FLAG PROCESSING OF FIRST FILE NAME
	CALL	LSN		LOCATE SOURCE NAMES

*	CRACK THE NEXT MAME

BLS1	MOV	A,M
	LXI	D,BLSA		(DE) = DEFAULT ADDRESS
	ANA	A
	RZ			NO MORE NAMES
	CALL	$SOB		SEE IF ALL NULL
	MOV	A,M
	ANA	A
	JNZ	BLS2		NOT ALL NULL
	LXI	H,BLSC		USE DEFAULT DEVICE
BLS2	CALL	CAD.		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR

*	IF FIRST NAME, RECORD DEVICE
*	IF NOT FIRST, COMPARE DEVICE AGAINST FIRST DEVISE

	PUSH	H
	LXI	D,PIO.DEV
	LXI	H,BLSA
	LXI	B,3		SETUP COUNT, FROM AND TO
	IF	.PIP.
	LDA	BLSB
	ANA	A
	JP	BLS3		NOT 1ST FILE
	CALL	$MOVE		MOVE IN REQUIRED DEVICE FOR REMAINING FILES
	XRA	A
	STA	BLSB		FLAG 1ST NAME PROCESSED
	JMP	BLS4
	ENDIF

BLS3	CALL	$COMP		SEE IF THIS DEVICE SAME AS PREVIOUS
	JE	BLS4		OK
	MVI	A,PEC.DNC	MULTIPLE DEVICES ARE ILLEGAL
	STC
	POP	H
	RET			RETURN WITH ERROR

*	GOT NAME DECODED. ENTER IN NAMTAB

BLS4	CALL	AEN		ADD ENTRY TO NAMTAB
	POP	H
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BLS1		SEE IF MORE

BLSA	DB	'SY0',200Q,200Q,200Q
BLSB	DB	0		FIRST FILE NAME FLAG
BLSC	DB	'SY0:',0		DEFAULT DEVICE
	SPACE	4,10
**	PFI - PRINT FILE INFO.
*
*	PFI DECODES A DIRECTORY ENTRY INTO A CODED LINE, THEN
*	WRITES IT TO 'DESTFB'.
*
*	THE PRODUCED FORMAT DEPENDS UPON THE LISTING FORMAT FLAG,
*	LSTA.
*
*	SHORT FORM:
*
*	NAME	.EXT	(TAB)
*
*	LONG FORM:
*
*	NAME	.EXT	SIZE	DATE	FLAGS	(NL)
*
*	ENTRY	(A) = SECTORS PER GROUP FOR THIS DEVICE
*		(DE) = DIRECTORY ENTRY POINTER
*	EXIT	IF LONG FORM, SECTOR COUNT IS ACCUMULATED IN LSTC
*	USES	ALL


PFI	STA	PFIC		SAVE SECTORS PER GROUP
	LXI	H,PFIA
	MVI	C,8
	CALL	PFI20		COPY NAME
	JZ	PFI1		ALL 8 CHARACTERS
	MVI	M,TAB
	INX	H
PFI1	MVI	M,'.'
	INX	H
	MVI	C,3
	CALL	PFI20		COPY EXTENSION
	MVI	M,TAB
	INX	H
	LDA	LSTA
	ANA	A
	JZ	PFI3		IS LONG FORM

*	IS SHORT FORM. SEE IF NEED TO END LINE

	INR	A
	CPI	5
	JNE	PFI2		NOT TIME YET
	DCX	H
	MVI	M,NL
	INX	H		TIME TO END LINE
	MVI	A,1
PFI2	STA	LSTA		RESET COUNT
	JMP	PFI6		OUTPUT TO FILE

*	IS LONG FORM.

PFI3	LXI	B,DIR.FGN-DIR.EXT-3
	XCHG			(DE) = LINE ADDR, (HL) = #PIO.DIR+DIR.EXT+3
	DAD	B		(HL) = #DIR.FGN
	MOV	A,M		(A) = (DIR.FGN)
	INX	H
	INX	H
	MOV	C,M		(C) = DIR.LSI = SECTORS USED IN LAST GROUP
	ERRNZ	DIR.LSI-DIR.FGN-2
	XCHG			(DE) = ADDRESS OF LSI
	PUSH	D		SAVE #DIR.LSI
	PUSH	H		SAVE LINE ADDRESS
	LHLD	LSTE
	MOV	L,A
	MOV	A,M
	CALL	CFS		COMPUTE FILE ISZE
	LDA	PFIC		(A) = SECTORS PER GROUP
	MOV	B,A						/80.06.GC/
	CALL	$MU86		(HL) = SECTORS USED (EXCEPT FOR THOSE IN LAST GROUP)

	LDA	ALLOCA						/80.06.gc/
	ANA	A						/80.06.gc/
	JZ	PFI3.5						/80.06.gc/
	MOV	C,B		Use Group Size instead if /ALL	/80.06.gc/
PFI3.5	EQU	*						/80.06.gc/

	MVI	B,0
	DAD	B		(HL) = SECTORS USED
	MOV	B,H
	MOV	C,L		(BC) = SECTORS USED COUNT
	LHLD	LSTC
	DAD	B
	SHLD	LSTC		ACCUMULATE COUNT OF SECTORS
	POP	H		(HL) = LINE ADDRESS
	MVI	A,4		3 DIGITS MAX			/80.05.gc/
	CALL	$UDDN		UNPACK COUNT
	MVI	M,TAB
	INX	H
	POP	D		(DE) = #DIR.LSI

*	TYPE DATE

	XCHG
	ERRNZ	DIR.CRD-DIR.LSI-1
	INX	H		(HL) = #DIR.CRD
	PUSH	H
	CALL	$HLIHL
	XCHG
	CALL	$DAD		DECODE AUGUSTAN DATE

*	CODE FLAGS

	XCHG			(DE) = LINE ADDRESS
	POP	H		(HL) = #DIR.CRD
	LXI	B,DIR.FLG-DIR.CRD
	DAD	B		(HL) = ADDRESS OF DIRFLG
	MOV	A,M		(A) = FLAGS
	XCHG			(HL) = LINE ADDRESS
	ANA	A
	JZ	PFI5.5		NO FLAGS
	MVI	M,TAB		TAB BEFORE FLAGS
	INX	H
	LXI	D,PFIB
PFI4	ADD	A
	JNC	PFI5		NOT SET
	PUSH	PSW		SAVE FLAGS
	LDAX	D
	MOV	M,A
	POP	PSW		RESTORE FLAGS
	INX	H
PFI5	INX	D		SET FLAG
	ANA	A
	JNZ	PFI4		MORE FLAGS SET
PFI5.5	MVI	M,NL
	INX	H

*	LINE ALL BUILT. WRITE TO DESTFB

PFI6	LXI	D,-PFIA
	DAD	D
	IF	.PIP.
	MOV	B,H
	MOV	C,L		(BC) = LEN
	LXI	D,PFIA		(DE) = DATA FWA
	LXI	H,DESTFB
	JMP	$FWRIB		WRITE AND EXIT
	ELSE
	MOV	A,L		(A) = COUNT
	LXI	H,PFIA
	JMP	$TYPCC		TYPE LINE AND EXIT
	ENDIF
	SPACE	4,10
**	PFI20 - COPY FILE NAME.
*
*	PFI20 COPIES A NAME FILED FROM THE DIRECTORY ENTRY TO A CODED
*	LINE
*
*	EENTRY	(DE) = DIRECTORY ADDRESS
*		(C) = NAME LENGTH
*		(HL) = LINE ADDRESS
*	EXIT	(DE) = (DE) + (C)
*		'Z' SET IF MAX CHARACTERS COPIED
*	USES	A,F,C,D,E,H,L


PFI19	MOV	M,A		CORY
	INX	H
	INX	D
	DCR	C
	RZ			ALL COPIED
PFI20	LDAX	D
	ANA	A
	JNZ	PFI19		GOT CHAR

*	NO NAME. (C) = COUNT LEFT

	MOV	A,E
	ADD	C
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	ORA	E		CLEAR 'Z'
	RET

PFIA	DS	0		BUFFER AREA FOR LINE BUILD
	DB	'XXXXXXXX.YYY	NNNN	DD-MMM-YY'
	DB	'		FLAGS         '
PFIB	DB	'SLW'		CODES
PFIB1	DB	' 1234'		 ('C' FOR CONTIGUOUS IS OPTIONAL)
	ERRNZ	DIF.SYS-200Q
	ERRNZ	DIF.LOC-100Q
	ERRNZ	DIF.WP-40Q
	ERRNZ	DIF.CNT-20Q
PFIC	DB	0		SECTORS PER GROUP FOR THIS DEVICE
	STL	'ERROR PROCESSING'
	EJECT
***	VERSN	- PIP VERSION INFORMATION
*
*	DEST=/V[ERSION]
*
*	PRINT THE PIP VERSION INFORMATION TO THE 'DEST' FILE.
*

VERSN	EQU	*

	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	STC
	JNZ	ERROR		TARGET FILE SPECIFICATION ILLEGAL
	LXI	H,LINE
	CALL	$SOB		SKIP OVER ALL THE BLANKS ($DRS TURNS SWITCHES
	MOV	A,M		 TO BLANKS)
	ANA	A
	MVI	A,PEC.SFI	SOURCE FILE ILLEGAL
	STC
	JNZ	ERROR		ONLY ALLOW SWITCH ON LINE
	CALL	$TYPTX

	IF	.PIP.
	DB	'PIP'
	ELSE
	DB	'ONECOPY'
	ENDIF

	DB	TAB,'Version:  '
*	DB	VERS/16+'0','.',VERS&00001111B+'0'
*	ASM has no '&' operator						/19.07.gr/
*									/19.07.gr/
	DB	VERS/16+'0','.','0'
	DB	ENL

	RET
	STL	'ERROR PROCESSING'
	EJECT
**	ERROR PROCESSING ROUTINES
*
	SPACE	3
***	NAMERR - FILE TYPE ERROR, OCCURRED ON FILE WHOSE NAME
*	IS NEXT UP IN NAMTAB.
*
*	PROCESS VIA $FERROR

	IF	.PIP.
NAMERR	LXI	H,NAMTAB-FB.NAM
	JMP	$FERROR
	ELSE
NAMERR	LHLD	NAMTPTR
	LXI	B,-FB.NAM
	DAD	B
	JMP	$FERROR
DESTERR SPACE	4,10
**	ERROR ON FILE IN DESTFB

DESTERR LXI	H,DESTFB
	JMP	$FERROR
	ENDIF
	SPACE	4
**	INTERNAL ERRORS. SHOULD NOT OCCUR.

IERR1	MVI	A,'1'
	JMP	INTERR

IERR2	MVI	A,'2'
	JMP	INTERR
IERR3	MVI	A,'3'
	JMP	INTERR


INTERR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,NL,'PIP INTERNAL ERROR ','#'+200Q
	POP	PSW
	CALL	$WCHAR
	CALL	$TYPTX
	DB	NL,'THIS ERROR SHOULD NOT OCCUR. CONTACT HEATH TECHNICAL'
	DB	NL,'CORRESPONDENCE FOR ASSISTANCE.',NL
	MVI	A,1
	DB	SYSCALL,.EXIT		ABORT
	EJECT
**	ERROR - GENERAL AND SYNTAX ERRORS NOT DIRECTLY ASSOCIATED
*	WITH A VALID FILE NAME.


ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,'ERROR -',' '+200Q
	POP	PSW
	ANA	A
	JM	ERROR1		IS PRODUCT ERROR
	MVI	H,NL		USE NL AS MESSAGE TRAIL CHAR
	DB	SYSCALL,.ERROR	LOOK UP SYSTEM ERROR
	JMP	RESTART

*	IS PRODUCT ERROR

ERROR1	LXI	H,ERRORA
ERROR2	CMP	M
	INX	H
	JNE	ERROR2		FIND ERROR MESSAGE
	IF	ONECOPY
	CALL	$TYPTX
	DB	BELL,'ONECOPY Error #',' '+200Q
	ENDIF
	DB	SYSCALL,.PRINT	PRINT MESSAGE
	JMP	RESTART

ERRORA	DS	0		ERROR MESSAGES
	IF	.PIP.
	DB	PEC.DF,'Device Format Error',ENL
	DB	PEC.DNC,'All Files Must Reside on the Same Device',ENL
	DB	PEC.TFI,'Destination File Specification is Illegal',ENL
	DB	PEC.CS,'Contradictory Switches Specified',ENL
	DB	PEC.IUW,'Illegal Use of Wildcard',ENL
	DB	PEC.IDF,'Illegal Destination File Format',ENL
	DB	PEC.SFI,'Source File Specification is Illegal',ENL
	ELSE
	DB	PEC.DF,'01',ENL
	DB	PEC.DNC,'02',ENL
	DB	PEC.TFI,'03',ENL
	DB	PEC.CS,'04',ENL
	DB	PEC.IUW,'05',ENL
	DB	PEC.IDF,'06',ENL
	DB	PEC.SFI,'07',ENL
	DB	PEC.FCI,'08',ENL
	ENDIF
	LON	LGCR
	STL	'SUBROUTINES'
	EJECT
**	AEN - ADD ENTRY TO 'NAMTAB'
*
*	AEN EXPANDS THE FILE INFO IN PIO.XXX INTO A FILE DESCRIPTOR
*	AND ENTERS IT IN THE NAMTAB TABLE.
*
*	ENTRY	NONE
*	EXIT	'C' SET IF WILDCARD
*	USES	ALL


AEN	LXI	H,AENA
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	SUI	1		'C' SET IF WILDCARD
	PUSH	PSW		SAVE FLAG
	LHLD	NAMTLEN
	LXI	B,FB.NAML
	DAD	B		INCREASE SIZE
	SHLD	NAMTLEN
	XCHG			(DE) = NEW LENGTH
	LHLD	NAMTMAX
	MOV	A,L		SEE IF WILL OVERFLOW
	SUB	E
	MOV	A,H
	SBB	D
	CC	INA		INCREASE NAMTAB ALLOCATION
	LXI	H,NAMTAB-FB.NAML
	DAD	D		(HL) = *TO* ADDRESS
	LXI	D,AENA		(DE) = *FROM* ADDRESS
	CALL	$MOVE		MOVE ENTRY IN
	POP	PSW		(PSW) = WILDCARD FLAG
	RET

AENA	DS	FB.NAML
	SPACE	4,10
**	BSL - BUILD SOURCE FILE LIST.
*
*	BSL CRACKS THE LIST OF THE SOURCE FILES FROM THE COMMAND LINE AND
*	BUILDS THEM INTO THE NAMTAB MANAGED TABLE.
*	WILD CARDS ENCOUNTERED ARE EXPANDED.
*
*	ENTRY	(A) <> 0 IF TO ASK ABOUT '*.*' USE
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL


BSL	STA	BSLA		SAVE ASK FLAG
	CALL	LSN		LOCATE SOURCE NAME

*	GO THROUGH SOURCE LIST CRACKING NAMES

BSL1	MOV	A,M
	ANA	A
	RZ			ALL DONE
	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	CALL	SND		SET NEW DEFAULTS
	PUSH	H		SAVE LINE ADDRESS
	LDA	BSLA
	ANA	A
	CNZ	CCW		CHECK FOR COMPLETE WILDCARD (*.*)
	JC	RESTART		USER CHICKENED OUT		/79.12.GC/
	CALL	EWS		EXPAND WILDCARD SPECIFICATION
BSL2	POP	H		RESTORE LINE ADDRESS
	RC			USER REFUSED *.*
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BSL1		DO MORE

BSLA	DB	0		<>0 IF TO CHECK FOR *.*
	SPACE	4,10
**	CCW - CHECK FOR COMPLETE WILDCARD.
*
*	CCW IS CALLED WITH A NAME CRACKED INTO PIO.XXX, TO SEE IF
*	IT IS A *.* SPECIFICATION.
*
*	IF SO, CCW ASKS,
*
*	DELETE ALL FILES ON DEV: ?!? (Y/N)
*
*	THE USER REPLY IS ACCEPTED AND DECODED.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF NOT *.*, OR 'Y' REPLIED
*		'C' SET IF *.* AND NOT 'Y'
*	USES	A.F,B,H,L


CCW	LXI	H,PIO.DIR+DIR.NAM
	IF	.PIP.
	MVI	B,8+3
	MVI	A,200Q
CCW1	ANA	M		SEE IF ALL HAVE 200Q BIT SET
	INX	H
	DCR	B
	JNZ	CCW1
	ANA	A
	RP			NOT *.*

*	IS *.*

	CALL	$TYPTX
	DB	BELL,'!?! DELETE ALL FILES ON',' '+200Q
	LXI	H,PIO.DEV
	MVI	A,3
	CALL	$TYPCC		TYPE DEVICE NAME
	CALL	$TYPTX
	DB	': (Y/N)?',' '+200Q
	LXI	H,DESTBUF
	CALL	$RTL.		READ REPLY
	LDA	DESTBUF
	CPI	'Y'
	RE			IS OK
	STC
	MVI	A,PEC.IUW	FLAG ILLEGAL USE OF WILDCARD
	ENDIF
	RET			FORGET IT
	SPACE	4,10
**	CFE - CHECK FILE ELIGIBILITY.
*
*	CFE CHECKS TO SEE IF A WILDCARD-SELECTED FILE IS ELIGIBLE
*	FOR PROCESSING. IF THE FILE IS FLAGGED SYSTEM, AND /S IS NOT
*	SPECIFIED, THE FILE IS NOT ELIGIBLE.
*
*	ENTRY	(HL) = DIRECTORY ENTRY POINTER
*	EXIT	'Z' SET IF ELIGIBLE
*	USES	A,F


CFE	PUSH	H
	MVI	A,DIR.FLG
	CALL	$DADA.
	MOV	A,M		(A) = FLAG
	ANI	DIF.SYS
	POP	H
	RZ			ELIGIBLE
	LDA	SYSTEM		CHECK /S FLAG
	ANA	A
	RET
	SPACE	4,10
**	CFS - COMPUTE FILE SIZE
*
*	CFS COMPUTES THE SIZE OF A FILE. THE DEVICE'S GRT MUST BE IN
*	THE 'GRT' BUFFER.
*
*	ENTRY	(A) = FIRST GROUP NUMBER
*	EXIT	(DE) = SIZE
*	USES	ALL


CFS	LHLD	LSTE
CFS.	LXI	D,0
CFS1	ANA	A
	RZ			ALL DONE
	MOV	L,A
	MOV	A,M		(A) = NEXT GRT
	INX	D
	JMP	CFS1		TRY AGAIN
	SPACE	4,10
**	CTS	-  CHECK TARGET FILE SPECIFICATION
*
*	CTS CHECKS FOR A TARGET FILE SPECIFICATION
*
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= 'Z' SET IF NO TARGET FILE
*			= 'Z' CLEAR IF    TARGET FILE
*			   (A)  = PEC.TFI ERROR CODE
*
*	USES	(PSW),(HL)
*

CTS	CALL	LSN		(HL) = ADDRESS OF FIRST SOURCE NAME
	LXI	D,-LINE
	DAD	D		(HL) == 0 IF NO '=' IN COMMAND LINE
	MOV	A,L
	ORA	H
	RZ			NO TARGET FILE
	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	RET			TARGET FILE SPECIFIED
	SPACE	4,10
**	CWM - CHECK WILDCARD MATCH.
*
*	CWM CHECKS TO SEE IF A WILDCARDED FIELD MATCHES A NON-WILDCARDED
*	FIELD.
*
*	ENTRY	(DE) = ADDRESS OF WC NAME
*		(HL) = ADDRESS OF NON/WC NAME
*		(B) = NUMBER OF CHARACTERS TO CHECK
*	EXIT	'Z' SET IF MATCH
*		 (HL) = (HL)+(B)
*		 (DE) = (DE) = (B)
*		'Z' CLEAR IF NO MATCH
*	USES	A,F,B,D,E,H,L


CWM	LDAX	D
	ANA	A
	JM	CWM1		IS MATCH
	CMP	M
	RNE			NO MATCH
CWM1	INX	D
	INX	H		ADVANCE ADDRESSES
	DCR	B
	JNZ	CWM		GO FOR MORE
	RET			GOT MATCH
	SPACE	4,10
**	DDF - DECODE DESTINATION FILE.
*
*	DDF DECODES THE DESTINATION FILE NAME FROM THE COMMAND LINE.
*
*	IF NO DESTINATION NAME IS SPECIFIED, IT DEFAULTS TO
*
*	KB:PIPDEST.JGL
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF OK
*		 (A) = 0 IF NAME HAS WILDCARDS
*		 (A) = 1 IF NO WILDCARD USED
*		 DESTFB+FB.NAM CONTAINS A COMPLETE DESTINATION FILE NAME
*		 (HL) = COMMAND LINE POINTER UDPATED
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL


DDF	LXI	D,LINE
	MOV	H,D
	MOV	L,E		(HL) = COMMAND POINTER
DDF1	LDAX	D
	INX	D
	CPI	'='
	JE	DDF2		HAVE A SOURCE FILE
	ANA	A
	JNZ	DDF1		MORE TO CHECK
DDF1.0	LXI	H,DDFA		USE DEFAULT

*	(HL) = ADDRESS FOR NAME

DDF2	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	JZ	DDF1.0		NO FILE NAME SPECIFIED, USE DEFAULT
	MOV	A,M
	CPI	'='
	MVI	A,PEC.IDF	ASSUME ILLEGAL DESTINATION FORMAT
	STC
	RNE			MUST HAVE '='

*	HAVE NAME DECODED. EXPAND INTO DESTFB+FB.NAM

	LXI	H,DESTFB+FB.NAM
	IF	.PIP.
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	ELSE	ONECOPY
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	PUSH	PSW		SAVE CODE
	MVI	C,3
	LXI	D,DDFB
	LXI	H,DESTFB+FB.NAM
	CALL	$COMP		SEE IF DEVICE IS SY0
	JNE	DDF3		IS ERROR
	POP	PSW
	RET			RETURN WITH 'C' CLEAR

DDF3	POP	PSW		ERROR, ILLEGAL DEVICE CODE
	MVI	A,EC.DNS
	STC
	RET

DDFA	DB	'SY0:*.*=',0	DEFAULT TARGET FOR ONECOPY
DDFB	DB	'SY0'		REQUIRED DEVICE SPECIFICATION FOR ONECOPY
	ELSE

DDFA	DB	'TT:PIPDEST.JGL=',0
	ENDIF
	SPACE	4,10
**	CAD - CONVERT ASCII FILE NAME INTO DIRECTORY FORMAT.
*
*	CAD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
*
*	DEV:NAME.EXT
*
*	INTO THE PIO.XXX FIELDS.
*
*	THE DEFAULT BLOCK DETERMINES THE VALUES FOR THE DEVICE AND EXTENSION
*	FIELDS, IF THEY ARE UNSPECIFIED. IF *CAD* IS ENTERED
*	AT *CAD*, AN UNSPECIFIED NAME FIELD IS RETURNED AS ZERO BYTES.
*	IF ENTERED AT *CAD.*, AN UNSPECIFIED NAME FIELD IS
*	RETURNED AS 200Q (MATCH-ONE) BYTES.
*
*	ENTRY	(DE) = POINT TO DEFAULT BLOCK
*		(HL) = POINTER TO TEXT
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		 (HL) = POINTS PAST FILE NAME
*		 'Z' SET IF NULL NAME
*		 'Z' CLEAR IF NON-NULL
*		  PIO.DIR.NAM = NAME
*		  PIO.DIR.EXT = EXTENSION
*		  PIO.DEV = DEVICE CODE
*		  PIO.UNI = UNIT NUMBER (ASCII DIGIT)
*	USES	ALL


CAD	XRA	A		SET TO NULLS
	JMP	CAD0

CAD.	MVI	A,200Q
CAD0	PUSH	H
	STA	CADA		SAVE DEFAULT VALUE

*	SET DEFAULTS IN PIO.xxx

	LXI	H,PIO.DEV
	LXI	B,3
	CALL	$MOVE		SET DEFALUT DEVICE
	LXI	B,3
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		SET DEFAULT EXTENSION
	POP	H
	CALL	$SOB		SKIP BLANKS
	MVI	B,0
	CPI	'?'
	JE	CAD1		IS '?'
	CPI	'*'
	JE	CAD1		IS '*'
	CPI	'.'
	JE	CAD1		IS '.'
	CPI	'A'
	JC	CAD4		NOT NAME
	CPI	'Z'+1
	JNC	CAD4		NOT NAME

*	HAVE ALPHA STRING. CRACK IT

CAD1	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR
	CPI	':'
	JNE	CAD2		NOT DEVICE

*	HAVE EXPLICIT DEVICE

	INX	H		SKIP '1'
	MVI	A,3
	CMP	C
	JC	CAD5		TOO MANY CHARACTERS
	MVI	A,PIO.UNI-PIO.DEV-1					/2.0b/
	CMP	C							/2.0b/
	JNC	CAD5		Too Few characters			/2.0b/

	MVI	A,'0'							/2.0b/
	STA	PIO.UNI		Assume Unit 0				/2.0b/
	MVI	B,0		BC = Move Count				/2.0b/
	PUSH	H		SAVE (HL)
	LXI	H,PIO.DEV
	CALL	$MOVE		SET EXPLICIT DEVICE
	POP	H
	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR

*	DECODE NAME

CAD2	LXI	B,8		(BC) = COUNT
	PUSH	H		SAVE TEXT ADDR

*	SEE IF NAME IS  UNSPECIFIED

	LXI	H,PIO.DIR+DIR.NAM
	PUSH	H		SAVE ADDRESS OF DIR.NAM
	CALL	$MOVE		MOVE IN NAME
	POP	H		(HL) = #PIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JNZ	CAD2.6		IS SPECIFIED
	LDA	CADA		(A) = FILL CHARACTER
	MVI	C,8		(C) = COUNT
CAD2.4	MOV	M,A
	INX	H
	DCR	C
	JNZ	CAD2.4
CAD2.6	POP	H
	MOV	A,M		(A) = DELIMITER
	CPI	'.'
	JNE	CAD3		NOT EXTENSION

*	HAVE EXPLICIT EXTENSION

	INX	H
	CALL	DNT
	JC	CAD5		ERROR
	MVI	A,3
	CMP	C
	JC	CAD5		TOO LONG
	LXI    B,3
	PUSH	H		SAVE TEXT POINTER
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		MOVE EXTENSION
	POP	H

*	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

CAD3	MVI	B,1		(B) = NAME PRESENT FLAG

*	END OF NAME. EXIT
*	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

CAD4	CALL	$SOB		SKIP BLANKS
	MOV	A,M		(A) = NEXT CHARACTER
	CALL	$CFD		CHECK FILE NAME DELIMITER
	RC			ERROR
	MOV	A,B
	ANA	A		SET 'Z' IF NULL
	RET

*	ERROR

CAD5	MVI	A,EC.IFN	ILLEGAL FILE NAME
	STC
	RET

CADA	DB	0		FILL CHARACTER FOR OMITTED NAME FIELD
	SPACE	4,10
**	DNT - DECODE NEXT TOKEN.
*
*	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
*
*	ENTRY	(HL) = TEXT POINTER
*	EXIT	'C' SET IF ERROR
*		'C' CLEAR IF OK
*		(A] = DELIMTER CHARACTER
*		(HL) UPDATED TO DELIMITER CHARACTER
*		(DNTA) = STRING
*		(C) = LENGTH
*		(DE] = #DNTA
*	USES	ALL


DNT	LXI	D,DNTA
	MVI	C,9		(C) = SIZE OF DNTA
	MOV	B,C		(B) = MAX ALLOWED +1
	XRA	A
DNT1	STAX	D		ZERO BUFFER
	INX	D
	DCR	C
	JNZ	DNT1
	LXI	D,DNTA

*	COPY CHARACTERS

DNT2	MOV	A,M
	CPI	'?'
	MVI	A,200Q
	JE	DNT3		IS MATCHONE
	MOV	A,M
	CPI	'*'
	JE	DNT5		IS WILDCARD
	CPI	'0'
	JC	DNT4		NOT ALPHANUMERIC
	CPI	'9'+1
	JC	DNT3		NUMERIC
	CPI	'A'
	JC	DNT4		DELIMITER
	CPI	'Z'+1
	JNC	DNT4		DELIMITER

*	HAVE GOOD CHARACTER

DNT3	STAX	D		STORE CHAR
	INX	D
	INX	H
	INR	C		COUNT
	DCR	B		LIMIT DECREMENT
	JNZ	DNT2		NOT OVERFLOW

*	OVERFLOW

	STC			FLAG ERR
	RET

*	IS '*' WILDCARD

DNT5	MVI	A,200Q
	STAX	D
	INX	D
	DCR	B
	JNZ	DNT5		FILL WITH MATCH ONE
	INX	H		SKIP '*'

*	END OF STRING

DNT4	ANA	A		CLEAR 'C'
	LXI	D,DNTA		SET POINTER
	RET

DNTA	DS	9		WORK AREA
	SPACE	4,10
**	EBM - EXPAND BUFFER TO MAXIMUM.
*
*	EBM IS CALLED TO EXPAND THE BUFFER 'BUF' TO THE MAXIMUM SIZE.
*	WHICH DOES NOT REQUIRE THE OVERLAYING OF THE SYSTEM.
*
*	ENTRY	NONE
*	EXIT	(BUFSIZ) = BUFFER SIZE (MULTIPLE OF 256)
*	USES	ALL


EBM	LHLD	S.SYSM
	PUSH	H
	LHLD	S.OFWA
	LXI	D,OVL0*OVL.ENS+OVL.FLB
	DAD	D		(HL) = ADDR. OF OVL0 OVL.FLB ENTRY
	MVI	A,OVL.RES
	ANA	M
	LXI	D,OVL.ENS
	DAD	D		(HL) = ADDR. OF OVL1 OVL.FLB ENTRY
	ERRNZ	OVL1-OVL0-1
	ANA	M
	JNZ	EBM1		OVL0 AND OVL1 ARE PERM. RESIDENT
	LHLD	S.OMAX
	CALL	$CHL
	XCHG
	POP	H
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	PUSH	H

EBM1	POP	H
	LXI	D,-6
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	DB	SYSCALL,.SETTP
	JC	IERR1		INTERNAL ERROR 1
	LHLD	S.USRM
	IF	.PIP.
	XCHG
	LHLD	BUFPTR
	CALL	$CHL		(HL) = - BUFFER FWA
	DAD	D
	MVI	L,0
	SHLD	BUFSIZ
	MVI	A,BUFMINL/256-1
	CMP	H
	RC			IF OK
	MVI	A,EC.NEM
	JMP	ERROR		NOT ENOUGH MEMORY

	ELSE

	MOV	A,H		(A) = LIMIT/256
	STA	OBUFLIM		SET LIMIT
	RET
	ENDIF
	SPACE	4,10
**	CDA - CONVERT DIRECTORY FORMAT TO ASCII.
*
*	CDA COPIES A DIRECTORY ENTRY FROM PIO.XXX TO A TARGET FIELD.
*	THE DEVICE SPECIFICATION (IN PIO.DEV AND PIO.UNI) IS ALSO ENCODED.
*	THE TARGET FIELD IS LEFT IN THE FORM:
*
*	DEV:NAME.XXX <00>
*
*	ENTRY	(HL) = FWA NAME FIELD
*	EXIT	(A) = 0, HAVE WILDCARD
*		    = 1, NO WILDCARDS USED
*		'C' CLEAR
*	USES	ALL


CDA	LXI	B,3*256		(B) = CHARACTER COUNT, (C) = WILDCARD FLAG
	LXI	D,PIO.DEV
	CALL	CDA5		COPY IT
	MVI	M,':'
	INX	H
	MVI	B,8
	LXI	D,PIO.DIR+DIR.NAM
	CALL	CDA5		COPY IT
	MVI	M,'.'
	INX	H
	MVI	B,3
	ERRNZ	DIR.EXT-DIR.NAM-8
	CALL	CDA5		COPY IT
	MVI	M,0		FLAG END OF NAME
	MOV	A,C		(A) (BIT 7) = 1 IF WILDCARDS
	RLC
	CMA
	ANI	1		=0 IF WILDCARD
	RET
	SPACE	2
**	CDA5 - CONVERT DIRECTORY FIELD TO ASCII.
*
*	ZEROS ARE IGNORED, 200Q WILDCARDS ARE MAPPED TO '?'
*
*	ENTRY	(DE) = FROM
*		(HL) = T0
*		(B) = COUNT
*		(C) = ORA ACCUMULATOR
*	EXIT	(DE) ADVANCED
*		(HL) = (HL)+(B)
*		(C) = (C) .OR. (FROM CHARACTERS PROCESSED)
*	USES	ALL


CDA5	LDAX	D		(A) = CHARACTER
	ORA	C
	MOV	C,A
	LDAX	D
	INX	D
	ANA	A
	JZ	CDA7		IS 00
	JP	CDA6		NOT 200Q
	MVI	A,'?'
CDA6	MOV	M,A
	INX	H		INCREMENT TO
CDA7	DCR	B
	JNZ	CDA5		IF MORE TO GO
	RET
	SPACE	4,10
**	EWS - EXPAND WILDCARD SPECIFICATION.
*
*	DWS ENTERS THE FILE NAME IN PIO.XXX INTO THE MANAGED TABLE
*	NAMTAB. IF THE FILE NAME CONTAINS WILDCARDS, THE DIRECTORY
*	IS READ FOR ELIGIBLE FILES.
*
*	ENTRY	PIO.XXX = FILE NAME
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*	USES	ALL


EWS	CALL	AEN		TRY TO ENTER IT
	RNC			NO WILDCARDS, AM DONE

*	IS WILDCARD. LOOK UP DEVICE TYPE

	LHLD	NAMTLEN
	LXI	D,NAMTAB-FB.NAML
	DAD	D		(HL) = ADDRESS OF LAST ENTRY
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D
	SHLD	NAMTLEN		REMOVE WILDCARD FROM TABLE
	CALL	$MOVEL
	DW	3,PIO.DEV,DIRNAM	SET DIRECTORY NAME IN XXX:DIRECT.SYS
	CALL	$MOVEL
	DW	8+3,PIO.DIR+DIR.NAM,EWSC	SAVE WILDCARD PATTERN
	LXI	B,EWSB
	LXI	H,DIRNAM
	DB	SYSCALL,.DECODE GET INFORMATION ABOUT DEVICE
	RC			ERROR
	LDA	EWSB		SEE IF A DIRECTORY DEVICE
	ANI	DT.DD
	MVI	A,EC.DNS		ASSUME DEVICE NOT SUITABLE
	STC
	RZ			ERROR

*	IS DIRECTORY DEVICE. OPEN DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	DB	SYSCALL,.OPENR
	MVI	A,PEC.DF
	RC			DEVICE FORMAT FAILURE

*	READ DIRECTORY ENTRYS FOR MATCH

EWS1	CALL	GDWP		DE = DIRECTORY WORKSPACE PTR	/79.11.GC/
	LXI	B,512
	MVI	A,CN.DIR
	PUSH	D		SAVE ADDRESS
	DB	SYSCALL,.READ	READ BLOCK
	POP	H		(HL) = DIRECTORY ADDRESS
	JC	EWS7		ALL DONE

*	LOOK AT DIRECTORY BLOCK FOR MATCHES

	PUSH	H						/79.11.GC/
	CALL	GDWP.						/79.11.GC/
	CALL	$INDLB						/79.11.GC/
	DW	DIS.ENL		A  = DIRECTORY ENTRY LENGTH	/79.11.GC/
	POP	H						/79.11.GC/

	MOV	C,A		(C) = LENGTH

*	CHECK NEXT ENTRY

EWS3	MOV	A,M		(A) = 1ST CHAR THIS ENTRY
	ANA	A
	JZ	EWS1		END OF BLOCK
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	EWS6		ENTRY EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	JZ	EWS7		END OF LIST
	CALL	CFE		CHECK FOR FILE ELIGIBILITY
	JNZ	EWS6		NOT TO PROCESS
	PUSH	H
	LXI	D,EWSC
	MVI	B,8+3
	CALL	CWM		CHECK WILDCARD MATCH
	JNZ	EWS4		NO MATCH

*	HAVE MATCH. ADD TO LSIT

	POP	D		(DE) = FROM
	PUSH	D
	PUSH	B		SAVE (C)
	LXI	B,8+3
	LXI	H,PIO.DIR+DIR.NAM
	CALL	$MOVE
	CALL	AEN		ADD TO TABLE
	POP	B		RESTORE (C)

*	LOOKUP NEXT ENTRY

EWS4	POP	H
EWS6	MVI	B,0
	DAD	B		POINT TO NEXT
	JMP	EWS3

*	ALL DONE. CLOSE DIRECTORY FILE

EWS7	MVI	A,CN.DIR
	DB	SYSCALL,.CLOSE
	RET

EWSA	DB	'SY0',200Q,200Q,200Q

EWSB	DS	30

EWSC	DS	8+3		WILDCARD PATTERN FOR DIRECTORY SEARCH
	SPACE	4,10
**	GDWP	-  GET DIRECTORY WORKSPACE POINTER		/79.11.GC/
*
*	GDWP GETS THE DIRECTORY WORKSPACE POINTER
*
*	ENTRY:	NONE
*
*	EXIT:	DE	= DIRECTORY WORKSPACE POINTER
*
*	USES:	DE
*

GDWP	XCHG
	CALL	GDWP.		HL = DIRECTORY WORKSPACE POINTER
	XCHG
	RET

GDWP.	LHLD	S.SCR		HL = SYSTEM SCRATCH
	RET
	SPACE	4,10
**	INA - INCREASE NAMTAB ALLOCATION.
*
*	INA IS CALLED TO INCREASE THE NAMTAB ALLOCATION. THE
*	BUFFER AREA IS MOVED UP TO MAKE ROOM.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,H,L

INA	LXI	H,NAMTMAX+1
	INR	M		INCREMENT LENGTH
	LXI	H,BUFPTR+1
	INR	M		MOVE BUFFER
	LHLD	BUFSIZ
	MOV	A,H
	ORA	L
	MVI	A,EC.NEM	FLAG OUT OF MEMORY IF BUFFER NOT EMPTY
	JNZ	ERROR
	PUSH	B
	PUSH	D
	CALL	SBE		NOTIFY SYSTEM
	POP	D
	POP	B
	RET
	SPACE	4,10
**	LSN - LOCATE SOURCE NAME
*
*	LSN SCANS THE COMMAND LINE FOR THE FIRST SOURCE FILE NAME.
*
*	ENTRY	NONE
*	EXIT	(HL) = 1ST FILE NAME FWA
*	USES	A,F,H,L

LSN	LXI	H,LINE
LSN1	MOV	A,M
	INX	H
	CPI	'='
	RE			GOT IT
	ANA	A
	JNZ	LSN1		MORE LINE
	LXI	H,LINE	IS NO =
	RET
	SPACE	4,10
**	MWN - MERGE WILDCARD NAMES.
*
*	MWN MERGES A COMPLETELY SPECIFIED FILENAME WITH A WILDCARDED COMPLETELY
*	SPECIFIED FILE NAME.
*
*	BOTH FILE NAMES SHOULD HAVE THE SAME DEVICE SPECIFICATION.
*
*	FILE NAME FORMAT:
*
*	DEV:NAMEXXXX.EXT 00
*
*	ENTRY	(BC) = ADDRESS OF WILDCARDED ASCII NAME
*		(DE) = ADDRESS OF NON-WC ASCII NAME
*		(HL) = ADDRESS FOR RESULTANT ASCII NAME
*	EXIT	NONE
*	USES	ALL


MWN	PUSH	H		SAVE TARGET ADDRESS
	PUSH	B		SAVE WC PATTERN
	XCHG			(HL) = MASTER NAME
	CALL	CAD		CONVERT TO DIRECTORY FORMAT
	CALL	$MOVEL
	DW	8+3,PIO.DIR,MWNA	(MWNA) = DECODED MASTER
	POP	H		(HL) = WC PATTERN
	CALL	CAD		(PIO.DIR) = WC PATTERN
	LXI	D,MWNA		(DE) = MASTER PATTERN
	LXI	H,PIO.DIR	(DE) = WC PATTERN ADDRESS
	MVI	C,8+3		MERGE NAME AND EXTENSION

*	MERGE NAMES

MWN1	MOV	A,M		(A) = WC PATTERN
	ANA	A
	JP	MWN2		USE THIS
	LDAX	D		IS MATCH CHARACTER, USE MASTER INSTEAD
MWN2	MOV	M,A		STORE CHARACTER
	INX	D
	INX	H
	DCR	C
	JNZ	MWN1		MERGE TILL DONE
	POP	H		(HL) = TARGET ADDRESS
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
	SPACE	4,10
**	REN - REMOVE ENTRY FROM *NAMTAB*
*
*	REN REMOVES THE FIRST 'FB.NAML' BYTES FROM NAMTAB.
*
*	THE AMOUNT (FB.NAML) IS REMOVED FROM THE SIZE OF THE TABLE. THE
*	TABLE IS NOT CHECKED FOR UNDERFLOW, THE CALLER MUST GUARANTEE THE
*	PRESENSE OF AT LEAST FB.NAML BYTES IN NAMTAB.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


REN	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D		REMOVE COUNT FROM LEN
	SHLD	NAMTLEN
	MOV	B,H
	MOV	C,L		(BC) = REMAINING LENGTH
	LXI	D,NAMTAB+FB.NAML	(DE) = START OF 2ND ENTRY
	LXI	H,NAMTAB
	JMP	$MOVE		MOVE DOWN AND RETURN
	SPACE	4,10
**	SBE - SET BUFFER EMPTY.
*
*	THE SYSTEM IS NOTIFIED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


SBE	LXI	H,0
	SHLD	BUFSIZ
	LHLD	BUFPTR		(HL) = BUFFER FWA (AND LWA!)
	INX	H
	INX	H
	DB	SYSCALL,.SETTP
	RNC			OK
	JMP	ERROR		NOT ENOUGH ROOM
	SPACE	4,10
**	SDD - SET DEFAULT DEFAULT.
*
*	SDD IS CALLED TO SETUP THE CURRENT DEFAULT DEVICE
*	AND EXTENSION TO 'SY0' AND <NULL>, RESPECTIVELY.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE


SDD	CALL	$SAVALL
	CALL	$MOVEL
	DW	6,SDDA,DEFALT	SET DEFAULT DEFAULT
	JMP	$RSTALL		RESTORE AND RETURN

SDDA	DB	'SY0',0,0,0	DEFAULT DEFAULT VALUES
	SPACE	4,10
**	SFS - SKIP FILE SEPERATOR.
*
*	SFS IS CALLED TO SKIP OVER THE CHARACTERS SEPERATING ONE
*	FILE NAME FROM ANOTHER ON THE LINE. THE FILES MAY BE SEPERATED
*	BY BLANKS OR A COMMA ALONE, OR BY BLANKS WITH A COMMA. THE
*	SYNTAX IS
*
*	<BLANKS> <,> <BLANKS>
*
*	ONE. TWO OR ALL THREE FIELDS MAY BE PRESENT.
*
*	ENTRY	(HL) = POINT TO START OF SEP FIELD
*	EXIT	(HL) ADVANCED PAST SEPERATOR FIELD
*	USES	A,F,H,L


SFS	CALL	$SOB		SKIP BLANKS
	MOV	A,M
	CPI	','
	JNE	SFS1		NOT ,
	INX	H		SKIP ,
SFS1	JMP	$SOB		GET ANY MORE BLANKS AND EXIT
	SPACE	4,10
**	SND - SET NEW DEFAULTS.
*
*	SND lS CALLED TO SET A NEW DEFAULT DEVICE AND EXTENSION
*	IN THE 'DEFALT' AREA.
*
*	ENTRY	PIO.DEV = DEVICE CODE
*		PIO.UNI = UNIT #
*		PIO.DIR+DIR.EXT = EXTENSION
*	EXIT	NONE
*	USES	NONE


SND	CALL	$SAVALL		SAVE REGS
	ERRNZ	PIO.UNI-PIO.DEV-2
	CALL	$MOVEL
	DW	3
	DW	PIO.DEV
	DW	DEFALT
	CALL	$MOVEL
	DW	3
	DW	PIO.DIR+DIR.EXT
	DW	DEFALT+3
	JMP	$RSTALL		RETURN
	STL	'COMMON DECKS'
	EJECT
	XTEXT	CFD
	XTEXT	TYPCC
	XTEXT	WER
	XTEXT	ZERO
	XTEXT	MU86
	XTEXT	CCO
	XTEXT	GNL
	XTEXT	MLU
	XTEXT	MCU
	XTEXT	RTL
	XTEXT	MOVE
	XTEXT	CHL
	XTEXT	SOB
	XTEXT	TBLS
	XTEXT	DADA
	XTEXT	TJMP
	XTEXT	CRLF
	XTEXT	TYPCH
$CMP$	EQU	1
	XTEXT	TYPLN
	XTEXT	TYPT2
	XTEXT	COMP
	XTEXT	SAVALL
	XTEXT	CDEHL
	XTEXT	UDD
	XTEXT	DU66
	XTEXT	DADA2
	XTEXT	HLIHL
	XTEXT	ILDEHL
	XTEXT	INDL
	XTEXT	INDXX
	XTEXT	ISDEHL
	XTEXT	DAD
	XTEXT	UDDN
	XTEXT	MOVEL
	XTEXT	RCHAR
	XTEXT	XCHGBC
	XTEXT	DRS
	IF	.PIP.
	XTEXT	DTB
	XTEXT	FOPE
	XTEXT	FWRIB
	XTEXT	FCLO
	XTEXT	FUTIL
	ENDIF
	STL	'ONECOPY SPECIAL DATA STRUCTURES'
	EJECT
PATCH	DS	64		PATCH AREA
	IF	ONECOPY							/2.0a/
	DS	*+255/256*256-* Auxiliary Patch Area (Round up 1 page)	/2.0a/
	ENDIF								/2.0a/
	STL	'ONECOPY SPECIAL DATA STRUCTURES'
	EJECT
	IF	ONECOPY


**	FDN - FILE DESCRIPTOR NODES.
*
*	THESE NODES ARE USED TO KEEP TRACK OF FILES WHICH ARE BEING
*	HELD IN MEMORY WHILE TRANSFERING.

FDN	DS	0		START OF TYPICAL NODE
FDN.LNK EQU	*-FDN		LINK TO NEXT NODE IN CHAIN
	DS	1		ALL IN SAME PAGE,  JUST KEEP PAGE INDEX
FDN.STA EQU	*-FDN		STATUS BYTE
ST.CNT	EQU	DIF.CNT		IS CONTIGUOUS
ST.OPR	EQU	00000010B	IS BEING READ
ST.OPW	EQU	00000001B	OPEN FOR WRITE
	DS	1		STATUS BYTE
FDN.SIZ EQU	*-FDN		TOTAL SIZE OF FILE (IF ST.CNT SET)
	DS	1		SIZE IN GROUPS
FDN.AMR EQU	*-FDN		AMOUNT ALREADY READ
	DS	2		 IN SECTORS
FDN.AMW EQU	*-FDN		AMOUNT ALREADY WRITTEN
	DS	2		 IN SECTORS
FDN.ADR EQU	*-FDN		ADDRESS IN BUFFER
	DS	1		 ADDRESS/256 (MUST BE EVEN PAGE)
FDN.AIM EQU	*-FDN		AMOUNT IN MEMORY
	DS	1		  IN SECTORS
FDNELEN EQU	*-FDN		ENTRY  LENGTH
	ORG	FDN		ORG BACK OVER DEFINITION AREA



**	TABLE. A LINK OF 0 IS A NULL LINK.
*
*	THE ENTIRE GROUP OF NODES MUST RESIDE
*	IN THE SAME PAGE

FDNFWA	EQU	*		START OF NODES

FDNFRE	DB	#FDN.1		START OF FREE CHAIN
FDNHEAD DB	0			ACTIVE LIST NOW EMPTY

FDN.1	DS	0
	DB	#FDN.2		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.2	DS	0
	DB	#FDN.3		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN,AIM

FDN.3	DS	0
	DB	#FDN.4		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.4	DS	0
	DB	#FDN.5		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.5	DS	0
	DB	#FDN.6		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.6	DS	0
	DB	#FDN.7		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.7	DS	0
	DB	#FDN.8		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDN.8	DS	0
	DB	0		FDN.LNK
	DB	0		FDN.STA
	DB	0		FDN.SIZ
	DW	0		FDN.AMR
	DW	0		FDN.AMW
	DB	0		FDN.ADR
	DB	0		FDN.AIM

FDNCNT	EQU	*-FDN.1/FDNELEN		NUMBER OF NODES

.	SET	*/256
	ERRNZ	FDNFWA/256-.	MUST BE ALL IN SAME PAGE

VOLFLAG DB	0		=0 IF READING FROM SOURCE, =377Q IF WRITTING TO BEST
VOLSER	DB	0		SERIAL NUMBER OF CURRENT DISK

OBUFLIM DB	0		BUFFER LIMIT/256
OBUFPTR DB	0		NEXT FREE PAGE IN BUFFER/256


	ENDIF

*	; APPEARS HERE TO ALLOW FDN. TO BE IN ONE PAGE
	XTEXT	FERROR

	STL	'PRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
ALLOCA	DB	0		/ALL flag (<>0 if /ALL specified) /80.06.gc/
COMAND	DB	0		COMMAND IN PROGRESS
MODE	DB	0		<>0 IF LINE PASSED ON STACK
JGL	DB	0		/JGL FLAG (<>0 IF /JGL SPECIFIED,
SUPRES	DB	0		/SUP FLAG (<>0 OF /SUP SPECIFIED)
SYSTEM	DB	1		/S FLAG (=0 IF /S SPECIFIED)

DIRNAM	DB	'XXX:DIRECT.SYS',0	DIRECTORY FILE NAME

BUFPTR	DW	BUFF		POINTER TO START  OF BUFFER
BUFSIZ	DW	0		BUFFER LENGTH
	SPACE	3
**	FILE BLOCKS

	IF	.PIP.
DESTFB	DS	0		DESTINATION FILE BLOCK
	DB	CN.DES		CHANNEL NUMBER
	DB	0		FLAGS
	DW	DESTBUF
	DW	DESTBUF
	DW	DESTBUF
	DW	DESTBFE		END OF BLOCK
	DS	FB.NAML		NAME AREA
	ELSE
DESTFB	DS	0		DUMY BUFFER
	DB	200		ILLEGAL CHANNEL NUMBER
	DB	0		FLAGS
	DW	0
	DW	0
	DW	0
	DW	0		END OF BLOCK
	DS	FB.NAML		NAME AREA
	ENDIF
	SPACE	3
NAMTLEN DW	0		NAME TABLE POINTER
NAMTMAX DW	0		MAXIMUM SIZE OF NAME TABLE
	IF	ONECOPY
NAMTPTR DW	0		POINTER TO ACTIVE ELEMENT IN NAMTAB
	ENDIF

	LON	LGCR
	STL	'RRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
***	PRS - PRESET PIP PROGRAM.
*
*	PRS IS CALLED TO PERFORM ONE-TIME-ONLY PRESETTING OF
*	THE PROGRAM ENVIRONMENT.
*
*	THE CODE IS OVERLAID BY BUFFERS AND WORK AREAS WHEN PIP IS RUNNING.
	IF	.PIP.
*	BE CAREFUL NOT TO USE ANY OF THE BUFFERS AND WORK AREAS BEFORE
*	THE AREA *LINE*.
	ELSE
*	DO NOT USE ANY OF THE BUFFERS AND WORK AREAS IN *PRS*
	ENDIF
*
*
*	ENTRY	NONE
*
*	EXIT	IF  CORRECT VERSION OF HDOS
*		    NONE
*		  ELSE
*		    EXIT TO HDOS
*
*	USES	ALL
*

ENTRY	EQU	*		INITIAL ENTRY POINT
PRS	DB	SYSCALL,.VERS
	JC	PRS1		ERROR IN GETTING VERSION
	CPI	VERS
	JNZ	PRS1		NOT CORRECT VERSION OF HDOS
	LXI	H,RMEML		(HL) = RUN-TIME HIGH MEMORY
	DB	SYSCALL,.SETTP	SET HI MEMORY
	JC	PRS2		IF  ERROR
	LXI	H,CCHIT
	MVI	A,CTLC
	DB	SYSCALL,.CTLC	SET CTL-C PROCESSING
	MVI	A,377Q
	DB	SYSCALL,.CLOSE	CLOSE OVERLAY CHANNEL
	IF	.PIP.

*	SEE IF COMMAND LINE PASSED ON STACK

	LXI	H,0
	DAD	SP
	XCHG
	MVI	A,#STACK
	SUB	E
	MOV	C,A
	MVI	A,STACK/256
	SBB	D
	MOV	B,A		(BC) = BYTES ON STACK
	ORA	C
	STA	MODE		SET MODE <>0 IF LINE ON STACK
	JZ	START		NO LINE

*	HAVE LCOMMAND ON STACK. COPY INTO LINE BUFFER
*	(BC) = COUNT
*	(DE) = FWA

	LXI	H,LINE
	CALL	$MOVE		COPY
	MVI	M,0		ENSURE END
	ELSE	ONECOPY
	CALL	$DOS		DISMOUNT OPERATING SYSTEM
	JC	PRS2		IF ERROR
	CALL	$TYPTX
	DB	NL,TAB,TAB,TAB,'   ','ONECOPY'
*	DB	NL,TAB,TAB,TAB,'Version:  ',VERS/16+'0','.',VERS&0FH+'0'
*	ASM has no '&' operator						/19.07.gr/
*									/19.07.gr/
	DB	NL,TAB,TAB,TAB,'Version:  ',VERS/16+'0','.','0'
	DB	NL,TAB,TAB,'      ','Issue:  #50.06.00 '
	DB	NL,NL,'	ONECOPY is used to copy files for systems with only one'
	DB	NL,'floppy drive. Read the appropriate manual before using.'
	DB	ENL
	CALL	$TYPTX
	DB	NL,'Insert the initial source disk. Hit RETURN when ready:',' '+200Q
	CALL	GDWP.						/79.11.GC/
	CALL	$RTL		GET CR

	JMP	PRS3		Jump the the rest of the code		/2.0a/
	ENDIF
	JMP	START		START PROGRAM

PRS1	MVI	A,EC.NCV	NOT CORRECT VERSION
	STC
PRS2	MVI	H,NL
	DB	SYSCALL,.ERROR
	JMP	EXIT

	IF	ONECOPY
	XTEXT	DTB
	XTEXT	DOS
	ENDIF

MEML	EQU	*		MEMORY LENGTH
	STL	'RUN-TIME WORK AREAS'
	EJECT
**	THE FOLLOWING BUFFERS AND AREAS OVERLAY THE PRS CODE.
*
*	*PRS* MAY NOT USE ANY CELLS BELOW *LINE*, AT THE
*	RISK OF SMASHING ITSELF

DEFALT	EQU	PRS		DEFAULT BLOCK

MWNA	EQU	DEFALT+6	MWN WORK AREA

	IF	.PIP.
DESTBUF EQU	MWNA+FB.NAML	DESTINATION FILE BUFFER (ALSO USED BY *CCW*)
DESTBFE EQU	DESTBUF+256	END OF BUFFER
	ELSE
DESTBFE	EQU	MWNA+FB.NAML
	ENDIF

**	* * NOTE * *
*	DIRWORK	 USES THE SYSTEM SCRATCH AREA, LABEL. DIRWORK WILL NOT
*	BE PRESERVED DURING A SYSCALL !!

SLABEL	EQU	DESTBFE		Saved Label Sector			/2.0a/
LABEL	EQU	SLABEL+256	Label Sector				/2.0a/

*DIRWORK	EQU	SECSCR		USE SECTOR SCRATCH AREA /79.11.GC/
	SPACE	3
**	PIO.XXX - IMAGE OF SYSTEM AIO.XXX AREA
*
*	THESE CELLS MIRROR THE SYSTEM AIO.XXX AREA


PIO.DEV EQU	LABEL+256	DEVICE CODE
PIO.UNI EQU	PIO.DEV+2	UNIT NUMBER (0-9)

PIO.DIR EQU	PIO.UNI+1	DIRECTORY ENTRY

$FOPWRK	EQU	PIO.DIR+DIRELEN	WORK AREA FOR $FOPE


	IF	.PIP.
	ERRMI	*-MEML		FOLLOWING MUST NOT OVERLAY *PRS*
	ENDIF
LINE	EQU	$FOPWRK+FB.NAML	COMMAND BUFFER


NAMTAB	EQU	LINE+80		NAME TABLE


BUFMINL EQU	512		MINIMUM SIZE FOR BUFFER (WHEN IN USE)
BUFF	EQU	NAMTAB		BUFFER AREA STARTS AFTER NAMTAB

RMEML	EQU	BUFF		INITIAL RUNNING MEMORY LENGTH



*	Heath assembler takes entry point on END statement	/19.07 gr/
	END	ENTRY						/19.07 gr/

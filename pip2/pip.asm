***	ALL PIP ALL THE TIME

	STL	''


***	PIP - PERIHPERAL INTERCHANGE PROGRAM.
*
*	  J. G. L , 11/1977 FOR *HEATH* COMPANY
*
*	COPYRIGHT 1977 BY HEATH COMPANY
*
*	      G. C.,	78/09	Maintenence Release
*			79/04
*
*			79/11	50.05.00
*			80	50.06.00
*				 /2.0a/ = /80.09.gc/
*				 /2.0b/ = /80.10.gc/
*
	SPACE	4,10
***	USE:
*
*	DEST=SOURCE1 [,SOURCE2,...,SOURCEN] L/SWITCH1.../SWITCHN:
*
*	SWITCHES:
*
*	/ALL[OCATE]
*	/R[ENAME]		RENAME
*	/DEL[ETE]	DELETE
*	/L[IST]		LIST
*	/B[RIEF]	BRIEF LIST
*	/S[YSTEM]	ENCLUDE SYSTEM FILES
*	/V[ERSION]	PIP VERSION NUMBER
*	/MOU[NT]	MOUNT DEVICE
*	/DIS[MOUNT]	DISMOUNT DEVICE
*	/RES[ET]	RESET DEVICE
*
*	/SU[PRESS]	SUPRESS
*	/JGL		WHO?
	EJECT
**	SYSTEM EQUIVALENCES

CN.SOU	EQU	0		SOURCE CHANNEL NUMBER
CN.DES	EQU	1		DESTINATION CHANNEL NUMBER
CN.DIR	EQU	2		DIRECTORY CHANNEL NUMBER

**	PROGRAM ERROR CODES

PEC.DF	EQU	200Q		DEVICE FORMAT ERROR
PEC.DNC EQU	201Q		DEVICES NOT CONSISTANT
PEC.TFI EQU	203Q		TARGET FILE ILLEGAL
PEC.CS	EQU	204Q		CONTRADICTORY SWITCHES
PEC.IUW EQU	205Q		ILLEGAL USE OF WILDCARD
PEC.IDF EQU	206Q		ILLEGAL DESTINATION FILE FORMAT
PEC.SFI EQU	207Q		SOURCE FILE ILLEGAL

	XTEXT	U8250
	XTEXT	U8251
	XTEXT	DIRDEF
	XTEXT	DIFDEF
	XTEXT	OVLDEF
	XTEXT	DEVDEF
	XTEXT	IOCDEF
	XTEXT	DISDEF
	XTEXT	FBDEF
	XTEXT	ECDEF
	XTEXT	HOSEQU
	XTEXT	HOSDEF
	XTEXT	ASCII
	XTEXT	ESINT
	XTEXT	ESVAL
	XTEXT	DDDEF
	XTEXT	MTR
	XTEXT	DDFDEF
	XTEXT	LABDEF
	XTEXT	FILDEF
	XTEXT	ABSDEF
	XTEXT	CPNET
DC.DSF	EQU	14
	STL	'MAIN ROUTINE'
	EJECT
*	Code header from original (cross-assembler)		/19.07.gr/
*	ORG	USERFWA-ABS.COD
*	DB	377Q,FT.ABS
*	DW	USERFWA		LOAD ADDRESS
*	DW	MEML-USERFWA	SIZE
*	DW	ENTRY		ENTRY
	ORG	USERFWA		ORG for Heath assembler		/19.07.gr/

PIP	EQU	*

*	COMMAND INTERPRETATION COMES HERE

RESTART EQU	*

	LDA	MODE
	ANA	A
	JNZ	EXIT		ENTERED WITH COMMAND, WILL NOW EXIT
START	LXI	SP,STACK	CLEAN STACK
	CALL	PIP1		EXECUTE COMMAND

*	COMMANDS EXIT HERE IF NO ERRORS FOUND

	JMP	RESTART

*	GET READY TO PROCESS COMMAND

PIP1	CALL	SDD		SET DEFAULT DEFAULT

*	CLEAR CHANNELS AND FILE BUFFER

	DB	SYSCALL,.CLEARA CLEAR CHANNELS
	XRA	A
	STA	DESTFB+FB.FLG	FLAG FILE NOT OPEN

*	CLEAR DYNAMIC BUFFERS

	LXI	H,0
	SHLD	BUFSIZ		EMPTY BUFFER
	SHLD	NAMTLEN		CLEAR NAMTAB
	SHLD	NAMTMAX		CLEAR NAMTAB AREA
	LXI	H,BUFF
	SHLD	BUFPTR		SET BUFFER AGAINST END OF NAMTAB

*	INPUT COMMAND LINE

	CALL	$CCO		CLEAR CONTROL-O
	LDA	MODE
	ANA	A
	CZ	ACL		ACCEPT COMMAND LINE (UNLESS WAS PASSED ONE BY CALLER)
	JC	EXIT		EOF
	LXI	H,LINE		(HL) = COMMAND ADDRESS
	LXI	D,PIPA		(DE) = SWITCH LIST
	ERRNZ	I.COP
	XRA	A		(A) = #I.COP
	STA	COMAND		ASSUME COPY COMMAND
	STA	SUPRES		CLEAR /SUP FLAG
	STA	ALLOCA		Clear /ALL flag			/80.06.gc/
	INR	A		FLAG NO /S FLAG
	STA	SYSTEM		CLEAR /S FLAG
	CALL	$DRS		DETECT AND REMOVE SWITCHES
	JC	ERROR		ERROR
	LDA	COMAND
	CALL	$TJMP		PROCESS COMMAND
	EJECT
**	COMMAND LIST

PIPB	DS	0		COMMAND PROCESSOR TABLE
I.COP	EQU	*-PIPB/2		COMMAND INDEX
	DW	COPY
I.LIS	EQU	*-PIPB/2		COMMAND INDEX
	DW	LIST
I.BRE	EQU	*-PIPB/2		COMMAND INDEX
	DW	BRIEF		/BR
I.VER	EQU	*-PIPB/2		COMMAND INDEX
	DW	VERSN		/V
I.MOU	EQU	*-PIPB/2	/MOU,/M
	DW	MOUNT
I.DEL	EQU	*-PIPB/2
	DW	DELETE		/DEL
I.REN	EQU	*-PIPB/2
	DW	RENAME		/RE
I.DIS	EQU	*-PIPB/2
	DW	DISMOU		/DIS
I.RES	EQU	*-PIPB/2
	DW	RESET		/RES

*	CTL-D HIT

EXIT	XRA	A
	DB	SYSCALL,.EXIT	EXIT
	SPACE	4,10
**	CCHIT - CTL-C HIT
*
*	ENTRY	FROM SYSTEM


CCHIT	CALL	$TYPTX
	DB	'^','C'+200Q
	DB	SYSCALL,.CLRCO	CLEAR CONSOLE TYPEAHEAD
	JMP	RESTART		GET NEW COMMAND
	STL	'SWITCH PROCESSING TABLES AND ROUTINES'
	EJECT
***	SWITCH PROCESSING TABLES AND ROUTINES.
*
*	COMMAND SWITCHES ARE PROCESSED VIA THE ROUTINE $DRS, 'DECODE AND
*	REMOVE SWITCHES'. $DRS IS SUPPLIED WITH A SWITCH DESCRIPTION
*	TABLE, WHICH CONTAINS THE ADDRESSES OF ROUTINES
*	WHICH ARE ENVOKED WHEN THE SWITCHES ARE ENCOUNTERED.


**	SWITCH TABLE

PIPA	DS	0		FWA SWITCH TABLE
	DB	'DEL'		/DELETE
	DB	'E'+200Q,'T'+200Q,'E'+200Q,200Q
	DW	SW.DEL		 PROCESSING ROUTINES

	DB	'R'		/RENAME
	DB	'E'+200Q,'N'+200Q,'A'+200Q,'M'+200Q,'E'+200Q,200Q
	DW	SW.REN		 PROCESS RENAME

	DB	'DIS'		/DISMOUNT
	DB	'M'+200Q,'O'+200Q,'U'+200Q,'N'+200Q,'T'+200Q,200Q
	DW	SW.DIS

	DB	'RES'		/RESET
	DB	'E'+200Q,'T'+200Q,200Q
	DW	SW.RES

	DB	'ALL'		/ALLOCATE			/80.06.gc/
	DB	'O'+200Q,'C'+200Q,'A'+200Q,'T'+200Q,'E'+200Q,200Q /.06.gc/
	DW	SW.ALL						/80.06.gc/

	DB	'L'		/LIST
	DB	'I'+200Q,'S'+200Q,'T'+200Q,200Q
	DW	SW.LIS		 PROCESS LIST

	DB	'B'		/BRIEF
	DB	'R'+200Q,'I'+200Q,'E'+200Q,'F'+200Q,200Q
	DW	SW.BRE		 PROCESS BRIEF

	DB	'V'		/VERSION
	DB	'E'+200Q,'R'+200Q,'S'+200Q,'I'+200Q,'O'+200Q,'N'+200Q,200O
	DW	SW.VER		PROCESS VERSION

	DB	'MOU'		/MOUNT
	DB	'N'+200Q,'T'+200Q,200Q
	DW	SW.MOU

	DB	'S'		/SYSTEM
	DB	'Y'+200Q,'S'+200Q,'T'+200Q,'E'+200Q,'M'+200Q,200Q
	DW	SW.SYS		 PROCESS SYSTEM

	DB	'SU'		/SUPRESS
	DB	'P'+200Q,'R'+200Q,'E'+200Q,'S'+200Q,'S'+200Q,200Q
	DW	SW.SUP

	DB	'JGL'		/JGL INTERNAL SWITCH
	DB	200Q
	DW	SW.JGL

	DB	0		END OF TABLE
	EJECT
	SPACE	3
**	SW.DEL - /DELETE SWITCH DETECTED.

SW.DEL	MVI	A,I.DEL
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.REN - /RENAME SWITCH DETECTED.

SW.REN	MVI	A,I.REN
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.DIS	-  /DISMOUNT SWITCH DETECTED

SW.DIS	MVI	A,I.DIS
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
**	SW.RES	-  /RESET SWITCH DETECTED.

SW.RES	MVI	A,I.RES
	JMP	SWIT1		IS MAJOR FUNCTION
	SPACE	3
*	SWIT1 - PROCESS MAJOR FUNCTION SWITCH.
*
*	SWIT1 IS ENTERED TO PROCESS SWITCHES WHICH DETERMINE THE FUNCTION
*	PIP IS TO PERFORM. I.E. 'VERB' SWITCHES, SUCH
*	AS /DELETE (AS OPOSED TO 'MODIFIER' SWITCHES, LIKE /SYSTEM)

SWIT1	LXI	B,COMAND
	PUSH	PSW		SAVE COMMAND
	LDAX	B		(A) = PREVIOUS COMMAND
	ANA	A
	MVI	A,PEC.CS	CONTRADICTORY SWITCHES
	JNZ	ERROR		IF SO
	POP	PSW		(A) = NEW CODE
	STAX	B		STORE IT
	RET
	EJECT
**	SW.ALL	- /ALLOCATE Switch Detected			 80.06.gc/

SW.ALL	MVI	A,1
	STA	ALLOCA
	RET
	SPACE	3
**	SW.SYS - /SYSTEM SWITCH DETECTED.

SW.SYS	XRA	A		SET /S FLAG
	STA	SYSTEM
	RET
	SPACE	4
**	SW.SUP - /SUPPRESS SWITCH.


SW.SUP	MVI	A,1
	STA	SUPRES
	RET
	SPACE	4
**	SW.JGL - /JGL SYSTEM SWITCH.


SW.JGL	MVI	A,1
	STA	JGL
	MVI	A,'C'
	STA	PFIB1		SET 'C' CHARACTER FOR FLAGS DISPLAY
	JMP	SW.SYS
	SPACE	3
**	SW.BRE - /BRIEF SWITCH DETECTED.

SW.BRE	LDA	COMAND		ALLOW TO SUPERCEDE /LIST
	ANA	A
	JZ	SW.BRE1		NO OTHER COMMAND
	ERRNZ	I.LIS-1
	DCR	A
	MVI	A,PEC.CS	ASSUME CONTRADICTORY SWITCHES
	JNZ	ERROR
SW.BRE1 MVI	A,I.BRE		IS /BREIF
	STA	COMAND
	RET
	EJECT
**	SW.LST - /LIST SWITCH DETECTED.

SW.LIS	LDA	COMAND
	ANA	A
	JZ	SW.LIS1		NO FUNCTION
	ERRNZ	I.BRE-2
	ERRNZ	I.LIS-1
	SUI	3
	CMC
	RNC			ALREADY HAVE ONE SPECIFIED, I.BRE OVERRULES
SW.LIS1 MVI	A,I.LIS		/LIST
	STA	COMAND
	RET
	SPACE	3
**	SW.VER	- /VERSION SWITCH DETECTED

SW.VER	MVI	A,I.VER
	JMP	SWIT1
	SPACE	3
**	SW.MOU	- /MOUNT SWITCH DETECTED

SW.MOU	MVI	A,I.MOU
	JMP	SWIT1
	LON	LGCR
	STL	'COPY - PROCESS COPY COMMAND.'
	EJECT
***	ACL - ACCEPT COMMAND LINE.
*
*	ACL PROMPTS FOR AND READS A COMMAND LINE FROM
*	THE CONSOLE.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR, GOT LINE
*		 'LINE' = COMMAND LINE
*		'C' SET IF EOF
*	USES	ALL


ACL	CALL	$GNL		GUARANTEE NEW LINE
	CALL	$TYPTX
	DB	':P',':'+200Q
	XRA	A
	STA	S.CSLMD		CLEAR SPECIAL MODES
	LXI	H,LINE
	JMP	$RTL.		READ UPPER CASE LINE AND EXIT
	STL	'COPY - PROCESS COPY COMMAND.'
	EJECT
***	COPY - PROCESS COPY COMMAND.
*
*	SYNTAX:
*
*	DEST=SOURCE1,...,SOURCEN
*
*	D'DEST' IS THE DESTINATION FILE DESIGNATOR. IF NULL
*	(IN WHICH CASE THE '=' MAY BE OMITTED) IT DEFAULTS  TO
*		KB:PIPDEST.JGL
*
*	THE 'SOURCE' FIELDS ARE THE SOURCE FILE DESIGNATORS. WILDCARDS
*	MAY BE USED FOR FILE NAME AND EXTENSION.
*	IF NO WILDCARDS ARE USED IN THE DESTINATION, MULTIPLE SOURCE FILES
*	ARE CONCATINATED TOGETHER.
*
*	IF WILDCARDS ARE PRESENT IN THE DESTINATION FILE DESCRIPTION,
*	THE SOURCE FILES ARE COPIED TO INDIVIDUAL OUTPUT FILES. THE
*	NAMES OF THE OUTPUT FILES ARE CREATED BY FILLING
*	THE 'WILD' SPOTS IN THE DESTINATION NAME WITH THE CORRESPONDING
*	CHARACTERS IN THE SOURCE NAME.


COPY	EQU	*
	XRA	A
	STA	COPYC		CLEAR FILE COUNT
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR		ERROR
	STA	COPYA		SAVE DESTIONATION TYPE
	CALL	SDD		RESET DEFAULT DEFAULTS
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR
	CALL	$MOVEL
	DW	COPYDL
	DW	DESTFB+FB.NAM
	DW	COPYD		SAVE WILDCARD DESTINATION

*	HAVE DESTINATION AND SOURCE FILE NAMES. DO THE COPYING.
*
*	IF NO DESTINATION WILD CARDS, THUS COPIING TO A SINGLE OUTPUT
*	FILE, OPEN THAT FILE NOW.

	LDA	COPYA
	ANA	A
	JZ	COPY1		IS WILDCARDED
	LXI	H,DESTFB+FB.NAM
	MVI	A,CN.DES	(A) = DESTINATION CHANNEL
	DB	SYSCALL,.OPENW		OPEN IT
	LXI	H,DESTFB
	JC	$FERROR		IF ERROR

*	OPEN NEXT SOURCE FILE

COPY1	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	COPY5		NO MORE INPUT FILES
	LXI	H,COPYC
	INR	M		COUNT FILE
	LXI	H,NAMTAB	(HL) = NAME ADDRESS
	MVI	A,CN.SOU	SOURCE CHANNEL
	DB	SYSCALL,.OPENR	OPEN FOR READ
	JC	NAMERR		IF ERROR

*	OPEN DESTINATION FILE IFF WILDCARDS

	LDA	COPYA
	ANA	A
	JNZ	COPY2		NOT WILDCARDS
	LXI	B,COPYD		(BC) = WILDCARD PATTERN ADDRESS
	LXI	D,NAMTAB	(DE) = SOURCE NAME
	LXI	H,DESTFB+FB.NAM (HL) = RESULT AREA
	PUSH	H		SAVE POINTER TO RESULT AREA
	CALL	MWN		MERGE WILDCARD NAME
	POP	H		(HL) = #DESTFB+FB.NAM
	MVI	A,CN.DES
	DB	SYSCALL,.OPENW
	LXI	H,DESTFB
	JC	$FERROR		CANT GET FILE OPEN

*	INPUT AND OUTPUT FILES OPEN. COPY

COPY2	CALL	EBM		EXPAND BUFFER TO MAX SIZE
COPY3	LHLD	BUFSIZ
	MOV	B,H
	MOV	C,L		(BC) = LENGTH OF BUFFER
	LHLD	BUFPTR
	XCHG			(DE) = BUFFER FWA
	MVI	A,CN.SOU
	PUSH	D
	DB	SYSCALL,.READ
	POP	D		(DE) = BUFFER FWA
	PUSH	PSW
	JNC	COPY4		GOT IT ALL
	CPI	EC.EOF
	JE	COPY4		IS EOF
	POP	PSW		RESTORE ERROR CODE
	JMP	NAMERR

COPY4	LDA	BUFSIZ+1	(A) = # OF SECTORS IN BUFFER
	SUB	B
	MOV	B,A		(B) = SECTORS READ
	MVI	C,0
	MVI	A,CN.DES
	DB	SYSCALL,.WRITE	WRITE IT OUT
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON WRITE
	POP	PSW		(PSW) = STATUS FROM READ
	JNC	COPY3		NOT EOF
	CALL	SBE		SHRINK BUFFER TO MINIMUM SIZE
	MVI	A,CN.SOU
	DB	SYSCALL,.CLOSE	CLOSE SOURCE
	JC	NAMERR		ERROR ON CLOSE
	CALL	REN		REMOVE ENTRY FROM NAMTAB

*	IF DOING INDIVIDUAL FILE COPIES, CLOSE OUTPUT FILE.

	LDA	COPYA
	ANA	A
	JNZ	COPY1		CONCATINATING
	MVI	A,CN.DES
	DB	SYSCALL,.CLOSE	CLOSE DESTINATION
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON CLOSE
	JMP	COPY1		GET NEXT FILE

**	ALL COPIES COMPLETE. CLOSE FILES AND CLEAN UP

COPY5	LDA	COPYC
	ANA	A
	JNZ	COPY6

*	NO FILES COPIED

	CALL	$TYPTX
	DB	BELL,'No Files Copied',ENL
	MVI	A,CN.DES
	DB	SYSCALL,.CLEAR	CLEAR CHANNEL
	RET

COPY6	MVI	B,0		(BC) = COUNT OF FILES COPIED
	MOV	C,A
	LDA	COPYA
	ANA	A
	JZ	COPY7		WILDCARDED
	PUSH	B		SAVE COUNT
	MVI	A,CN.DES
	DB	SYSCALL,.CLOSE	CLOSE DESTINATION
	POP	B		(BC) = FILES COPIED COUNT
	LXI	H,DESTFB
	JC	$FERROR		ERROR ON CLOSE

*	TYPE FILE COUNT

COPY7	LDA	SUPRES
	ANA	A
	RNZ			SUPPRESS TRAIL MESSAGE
	MVI	A,3
	LXI	H,COPYE
	CALL	$UDDN		UNPACK COUNT INTO MESSAGE
	CALL	$TYPTX
	DB	NL
COPYE	DB	'XXX'
	DB	' Files Copied',ENL
	RET

COPYA	DB	0		DESTINATION FILE WILDCARD FLAG (=0 IF WC)
COPYC	DB	0		FILES COPIED COUNT
COPYD	DS	FB.NAML		HOLD AREA FOR WILDCARD DESTINATION
COPYDL	EQU	*-COPYD
	STL	'DISMOU - DISMOUNT CURRENT DISK'
	EJECT
***	MOUNT	-  MOUNT A NEW DISK
*
*	MOUNT MOUNTS A NEW DISK ON THE SPECIFIED UNIT OF THE SELECTED
*	DEVICE.
*
*	DEV:/MOU[NT]
*

MOUNT	EQU	*
	MVI	A,.MOUNT
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	LON	LGCR
	STL	'RESET	 -  RESET CURRENT DISK'
	EJECT
***	DISMOU	-  DISMOUNT CURRENT DISK
*
*	DISMOU DISMOUNTS THE CURRENT DISK ON THE SPECIFIED UNIT OF THE
*	SELECTED DEVICE.
*
*	DEV:/DIS[MOUNT]
*

DISMOU	EQU	*
	MVI	A,.DMOUN
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	LON	LGCR
	EJECT
***	RESET	-  RESET THE CURRENT DISK
*
*	RESET RESETS THE SPECIFIED UNIT OF THE SELECTED DEVICE BY ISSUING
*	THE HDOS RESET CALL, WHICH IN TURN ISSUES A DISMOUNT AND MOUNT
*	ASKING THE USER TO OPEN THE DRIVE IN BETWEEN THE TWO.
*
*	DEV:/RES[ET]
*

RESET	EQU	*
	MVI	A,.RESET
	CALL	MDR.		MOUNT/DISMOUNT/RESET
	RET
	SPACE	4,10
**	MDR.	-  MOUNT/DISMOUNT/RESET
*
*	MDR. PERFORMS THE SIMILAR FUNCTIONS OF MOUNT, DISMOUNT, AND RESET.
*
*
*	ENTRY	(A)	=  SYSCALL CODE FOR OPERATION TO BE PERFORMED
*
*	EXIT	IF  NO ERROR
*		    TO CALLER
*		  ELSE
*		    TO ERROR
*
*	USES	ALL
*

MDR.	STA	MDRA		STORE SYSCALL VALUE
	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	STC
	JNZ	ERROR		THERE WAS A TARGET FILE
	LXI	H,LINE
	CALL	$DTB		DELETE TRAILING BLANKS
	CPI	1		(A) = LINE LENGTH INCLUDING <00> BYTE
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JZ	ERROR		NULL DEVICE IS ILLEGAL, ONLY BYTE IS NULL
MDR1	PUSH	H		SAVE SPEC. ADDRESS FOR RETRY
	DB	SYSCALL,0
MDRA	EQU	*-1		SYSCALL VALUE
	POP	H
	RNC			NO ERROR
	PUSH	H		SAVE SPEC. ADDRESS
	CPI	EC.NPM		NO PROVISIONS MADE FOR REMOUNT
	STC
	JNZ	ERROR		ALL ERRORS BUT 'EC.NPM' CONSIDERED FATAL
	MVI	A,OVL0
	DB	SYSCALL,.LOADO	LOAD *HDOSOVL0.SYS*
	JC	ERROR
	MVI	A,OVL1
	DB	SYSCALL,.LOADO	LOAD *HDOSOVL1.SYS*
	JC	ERROR		SYSCALL ERROR
	POP	H		RESTORE SPEC. ADDRESS
	JMP	MDR1		TRY AGAIN
	STL	'RENAME - PROCESS RENAME COMMAND'
	EJECT
***	DELETE - PROCESS DELETE COMMAND.
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/DELETE
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	IF *.* IS SPECIFIED, DELETE ASKS,
*		DELETE ALL ?!? ARE YOU SURE?


DELETE	EQU	*
	LXI	H,LINE

*	SEE IF A DESTINATION FILE SPECIFIED

DEL1	MOV	A,M
	INX	H
	ANA	A
	JZ	DEL2		END OF LINE
	CPI	'='
	JNE	DEL1

*	HE SPECIFIED A DESTINATION FILE

	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	JMP	ERROR		FORMAT ERROR

*	NO TARGET FILE SPECIFIED

DEL2	MVI	A,1		CHECK FOR *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR		NO GOOD

*	DELETE FILES ONE BY ONE

DEL5	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	RZ			END OF LIST
	LXI	H,NAMTAB
	CALL	DELNET		TRY NETWORK DELETE FIRST
	JC	NAMERR		ERROR ON DELETE
	JZ	DEL6		PROCESSED BY NETWORK
	DB	SYSCALL,.DELET	REMOVE IT
	JC	NAMERR		ERROR ON DELETE
DEL6	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	DEL5		DELETE THE NEXT ONE
	STL	'RENAME - PROCESS RENAME COMMAND'
	EJECT
***	RENAME - RENAME FILES.
*
*	SYNTAX:
*
*	DEST = SOURCE1,...,SOURCEN
*
*	RENAME IS PROCESSED IN A MANNER SIMILAR TO COPY, EXCEPT THAT THE
*	FILE IS RENAMED, RATHER THAN COPIED.


RENAME	EQU	*
	CALL	DDF		DECODE DESTINATION FILE
	JC	ERROR
	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCEFILE LIST
	JC	ERROR

*	DO MULTIPLE RENAMES

REN1	LXI	B,DESTFB+FB.NAM (BC) = WILDCARDED TARGET NAME
	LXI	D,NAMTAB	(DE) = NORMAL SOURCE NAME
	LXI	H,RENA		(HL) = BUFFER FOR RESULT NAME
	PUSH	B		SAVE #DESTFB+FB.NAM
	PUSH	D		SAVE #NAMTAB
	CALL	MWN		MERGE WILDCARD NAME
	POP	D		(DE) = #NAMTAB
	POP	H		(HL) = #DESTFB+FB.NAM


*	SEE IF SOURCE AND DEST FILE ON SAME DEVICE

	PUSH	D		SAVE #NAMTAB (SOURCE NAME)
	MVI	C,3
	CALL	$COMP		COMPARE DEVICES
	MVI	A,PEC.DNC	DEVICES NOT CONSISTANT
	JNE	ERROR

*	SEE IF TARGET ALREADY EXISTS

	LXI	H,RENA
	MVI	A,CN.SOU
	DB	SYSCALL,.OPENR
	LXI	H,RENA-FB.NAM
	JC	REN2		HAVE AN ERROR (AS WE SHOULD)
	MVI	A,EC.FAP	FILE AALREADY PRESENT
	JMP	$FERROR		ALREADY THERE

REN2	CPI	EC.FNF		MUST BE NOT FOUND
	JNE	$FERROR		OTHER ERROR
	POP	H		(HL) = SOURCE NAME
	LXI	B,RENA		(BC) = NEW (TARGET) NAME
*	ALL FILES ON SAME DEVICE, EWS ALREADY DETECTED IF NETOWRK
	LDA	NETOP
	ORA	A
	JNZ	RENNET
	DB	SYSCALL,.RENAM	RENAME IT
	JC	NAMERR		ERROR ON RENAME

*	REMOVE NAME FROM NAMTAB

REN6	CALL	REN		REMOVE ENTRY FROM NAMTAB
	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JNZ	REN1
	RET

RENA	DS	FB.NAML		FILE NAME WORK AREA
	STL	'LIST - LIST DIRECTORY CONTENTS'
	EJECT
***	LIST - INDEX DIRECTORY.
*
*	DEST=SOURCE/LIST
*		   /BRIEF
*
*	THESE SWITCHES CAUSE THE DIRECTORY CONTENTS OF THE SPECIFIED FILE(S)
*	TO BE LISTED
*
*	IN /LI FIRM, THE OUTPUT IS:
*
*	NAME	EXT	SIZE	  DATE		FLAGS
*	XXX	.XXX	 NNN	DD-MMM-YY	CWS
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*	 .	 .	 .	   .		 .
*		NNN FILES USING MMM SECTORS, XXX FREE
*
*	IN /BR FORM, ONLY THE NAME AND EXTENSION ARE LISTED,
*	4 ACROSS THE PAGE.
*
*	SPECIAL CONSIDERATIONS:
*
*	A NULL NAME OR EXTENSION IS TAKEN AS '*' (WILDCARD)
*
*	IMPLIMENTATION:
*
*	A FILE LIST OF SOURCE FILES IS BUILT. THE DEVICE DIRECTORY FILE
*	IS THEN READ, AND EACH FILE IN IT IS CHECKED FOR A MATCH
*	AGAINST ANY SOURCE SPECIFICATIONS. ELIGIBLE FILES ARE LISTED.


LIST	LXI	H,0
	JMP	LIST1

BRIEF	LXI	H,1
*	JMP	LIST1

LIST1	SHLD	LSTA		(LSTA) = 0 IF LIST, 1 IF /BRIEF
	ERRNZ	LSTB-LSTA-1	LSTB   FILE COUNT
	LXI	H,0
	SHLD	LSTC		CLEAR SECTORS USED COUNT
	CALL	$MOVEL
	DW	9,S.DATE,LSTG1	SET DATE IN HEADING

*	CRACK DESTINATION FILE NAMES

	CALL	DDF		DECODE DEST FILE NAME
	JC	ERROR		FILE NAME ERROR
	ANA	A
	MVI	A,PEC.IUW	ILLEGAL USE OF WILDCARD IN DEST
	JZ	ERROR

*	BUILD LIST OF SPECIFICATIONS

	CALL	BLS		BUILD LIST OF SOURCE SPECS
	JC	ERROR		ERROR IN LIST
	LXI	B,3
	LXI	H,DIRNAM
	CALL	$MOVE		MOVE DEVICE CODE INTO DIRECT.SYS NAME
	LXI	H,DIRNAM+2
	MOV	A,M		SEE IF UNIT NUMBER OMITTED
	ANA	A
	JNZ	LIST1.5		SPECIFIED
	MVI	M,'0'		DONT ALLOW NULL NUMBER

*	GET ADDRESS OF DEVICE'S GRT

LIST1.5 LXI	H,DIRNAM	(HL) = # OF XXX:DIRECT.SYS (XXX = DEVICE)
	LXI	B,LSTD		(BC) = ADDRESS FOR RETURN INFO
	DB	SYSCALL,.DECODE		DECODE NAME
	JC	ERROR		UNKNOWN DEVICE
	LHLD	LSTD+17		(HL) = DEV TBL ADDR		/80.04.gc/
	LDA	LSTD+0
	ANI	DT.DD+DT.RN
	CPI	DT.RN
	JZ	LSTNET		NETWORK DEVICE
	ANI	DT.DD
	MVI	A,EC.DNS
	JZ	ERROR		NOT DIRECTORY DEVICE
	XRA	A
	STA	NETOP

	LXI	D,DEV.UNT					/80.04.gc
	DAD	D
	LDA	LSTD+3
	CALL	S.GUP		HL = UNIT TABLE POINTER

	CALL	$INDLB						/80.04.gc/
	DW	UNT.SPG						/80.04.gc/
	STA	LSTF		SAVE  SECTORS PER GROUP		/80.04.gc/

	CALL	$INDL
	DW	UNT.GRT
	XCHG
	SHLD	LSTE		SAVE  GRT ADDRESS
	XCHG

*	OPEN DEVICE'S DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	DB	SYSCALL,.OPENR
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JC	ERROR		CANT OPEN DIRECTORY

	CALL	LSTSUP		SETUP FOR LISTING

*	READ DIRECTORY BLOCKS, LOOKING FOR FILE MATCHES

LIST3	LXI	B,512
	CALL	GDWP		DE = DIRECTORY WORKSPACE POINTER  /79.11.GC/
	MVI	A,CN.DIR
	PUSH	D						/79.11.GC/
	DB	SYSCALL,.READ
	POP	D		DE = DIRECOTRY WORKSPACE	/79.11.GC/
	JC	LIST9		ALL DONE

*	CHECK NEXT ENTRY IN NAMTAB AGAINST DIRECTORY ENTRY.
*	(DE) = DIRECTORY BUFFER POINTER

LIST4	LDAX	D		(A) = FIRST CHARACTER OF NAME
	ANA	A
	JZ	LIST3		END OF THIS BUFFER
	INR	A
	ERRNZ	DF.EMP-377Q
	JZ	LIST7		THIS ENTRY IS EMPTY
	INR	A
	JZ	LIST9		NO MORE ENTRYS IN DIRECTORY
	XCHG
	CALL	CFE		CHECK FILE ELIGIBILITY
	XCHG
	JNE	LIST7		NOT ELIGIBLE
	LXI	H,NAMTAB

LIST5	PUSH	H
	PUSH	D		SAVE ADDRESS OF FILE AND PATTERN
	CALL	CAD		CONVERT ASCII NAMTAB ENTRY TO DIRECTORY FORMAT
	LXI	D,PIO.DIR+DIR.NAM	(DE) = NAMTAB PATTERN
	POP	H
	PUSH	H		(HL) = DIRECTORY PATTERN
	MVI	B,8+3		CHECK FOR MATCH
	CALL	CWM		CHECK FOR WILDCARD MATCH
LIST6	POP	D
	POP	H
	JE	LIST8		GOT FILE TO LIST
	LXI	B,FB.NAML
	DAD	B		ADVANCE PAST ENTRY IN NAMTAB

*	SEE IF AT END OF NAMTAB

	PUSH	D
	XCHG			(DE) = NEW ADDRESS
	LHLD	NAMTLEN
	LXI	B,NAMTAB
	DAD	B		(HL) = LWA+1 OF TABLE
	XCHG
	CALL	$CDEHL		COMPARE
	POP	D
	JNE	LIST5		MORE IN TABLE

*	FILE DOESNT MATCH ANY SELECTED FILE. PASS TO NEXT ONE

LIST7	XCHG			(HL) = DIR BUFFER ADDRESS

	PUSH	H						/79.11.GC/
	CALL	GDWP.		HL = DIRECTORY WORKSPACE PTR.	/79.11.GC/
	CALL	$INDLB		A  = DIR. ENTRY LENGTH		/79.11.GC/
	DW	DIS.ENL						/79.11.GC/
	POP	H						/79.11.GC/

	CALL	$DADA.		ADVANCE
	MOV	A,M
	ANA	A
	XCHG
	JNZ	LIST4		TRY THIS ONE
	JMP	LIST3		READ ANOTHER BLOCK

*	HAVE FILE TO LIST

LIST8	PUSH	D		SAVE DIR POINTER
	LDA	LSTF		(A) = SECTORS PER GROUP THIS DEVICE
	CALL	PFI		PRINT FILE INFO
	POP	D
	LXI	H,LSTB
	INR	M		COUNT FILE
	JMP	LIST7		ADVANCE TO NEXT FILE

*	ALL DONE. CLOSE DIRECTORY FILE

LIST9	MVI	A,CN.DIR
	DB	SYSCALL,.CLOSE	CLOSE FILE
LIST9.1	LXI	B,1		ASSUME SHOFT FORM, JUST WRITE NL
	LDA	LSTA		(A) = FORM FLAG
	ANA	A
	JNZ	LIST10		IS SHORT, NO TRAILER

*	PRINT SUMMARY:
*
*	NNN FILES, USING XXX SECTORS. YYY FREE

	LDA	LSTB
	MOV	C,A
	MVI	B,0		(BC) = FILE COUNT
	MVI	A,3
	LXI	H,LSTH1
	CALL	$UDDN		FILE COUNT

	LHLD	LSTC
	MOV	B,H
	MOV	C,L		(BC) = SECTOR COUNT
	LXI	H,LSTH2
	MVI	A,4						/80.05.gc/
	CALL	$UDDN		USED COUNT

	LDA	NETOP
	ORA	A
	LXI	B,9999
	JNZ	LIST9.5
	LHLD	LSTE
	MOV	A,M
	CALL	CFS		FOLLOW GRT CHAIN
	LDA	LSTF
	CALL	$MU86		(HL) = SECTORS FREE
	MOV	B,H
	MOV	C,L
LIST9.5	LXI	H,LSTH3
	MVI	A,4						/80.05.gc/
	CALL	$UDDN		UNPACK FREE

	LXI	B,LSTHL
LIST10	LXI	D,LSTH
	LDA	SUPRES
	ANA	A
	LXI	H,DESTFB
	JNZ	$FCLO		CLOSE AND EXIT, SUMMARY SUPPRESSED
	CALL	$FWRIB		WRITE TRAILER

*	ALL DONE. CLOSE OUTPUT FILE

	JMP	$FCLO		CLOSE AND EXIT

LSTA	DB	0		<>0 IFF SHORT FORM

LSTB	DB	0		FILE COUNT
LSTC	DW	0		SECTORS USED
LSTD	DS	24		FILE NAME DECODE AREA
LSTE	DW	0		GRT ADDRESS
LSTF	DB	0		SECTORS PER GROUP FOR THIS DEVICE
LSTG	DB	NL,'Name',TAB,'.Ext',TAB,'Size',TAB,'  Date',TAB,TAB,'Flags',TAB
LSTG1	DS	9		DATE
	DB	NL,NL
LSTGL	EQU	*-LSTG

LSTH	DB	NL,'   '		FIRST CHARACTER MUST BE <NL>
LSTH1	DB	'NNN Files, Using '
LSTH2	DB	'MMMM Sectors ('
LSTH3	DB	'XXXX Free)',NL
LSTHL	EQU	*-LSTH
	SPACE	4,10
**	BLS - BUILD LIST OF SOURCE FILES.
*
*	BLS BUILDS A LIST OF SOURCE FILES INTO *NAMTAB*
*	NULL FIELDS ARE SET TO WILDCARDS. BLS REQUIRES THAT ALL
*	FILES SPECIFIED HAVE THE SAME DEVICE.
*
*	IF THE COMMAND LINE CONTAINS NO FILES. BUT CONTAINS AT LEAST
*	ONE BLANK (AS WOULD BE THE CASE IN PROCESSING THE /LIST SWITCH, SINCE
*	THE '/LIST' IS REPLACED WITH BLANKS) A FILE NAME OF ????????.???
*	IS DECODED.
*	ENTRY	NAMTAB EMPTY
*	EXIT	'C' CLEAR IF OK
*		(DE) = #BLSA = 3 CHARACTER DEVICE NAME
*		'C' SET IF ERROR
*		 (A) = ERROR MESSAGE
*	USES	ALL


BLS	CALL	$MOVEL
	DW	3,BLSC,BLSA	SET INITIAL DEFAULT DEVICE
	LXI	H,0
	SHLD	NAMTLEN		CLEAR NAMTAB
	MVI	A,377Q
	STA	BLSB		FLAG PROCESSING OF FIRST FILE NAME
	CALL	LSN		LOCATE SOURCE NAMES

*	CRACK THE NEXT MAME

BLS1	MOV	A,M
	LXI	D,BLSA		(DE) = DEFAULT ADDRESS
	ANA	A
	RZ			NO MORE NAMES
	CALL	$SOB		SEE IF ALL NULL
	MOV	A,M
	ANA	A
	JNZ	BLS2		NOT ALL NULL
	LXI	H,BLSC		USE DEFAULT DEVICE
BLS2	CALL	CAD.		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR

*	IF FIRST NAME, RECORD DEVICE
*	IF NOT FIRST, COMPARE DEVICE AGAINST FIRST DEVISE

	PUSH	H
	LXI	D,PIO.DEV
	LXI	H,BLSA
	LXI	B,3		SETUP COUNT, FROM AND TO
	LDA	BLSB
	ANA	A
	JP	BLS3		NOT 1ST FILE
	CALL	$MOVE		MOVE IN REQUIRED DEVICE FOR REMAINING FILES
	XRA	A
	STA	BLSB		FLAG 1ST NAME PROCESSED
	JMP	BLS4

BLS3	CALL	$COMP		SEE IF THIS DEVICE SAME AS PREVIOUS
	JE	BLS4		OK
	MVI	A,PEC.DNC	MULTIPLE DEVICES ARE ILLEGAL
	STC
	POP	H
	RET			RETURN WITH ERROR

*	GOT NAME DECODED. ENTER IN NAMTAB

BLS4	CALL	AEN		ADD ENTRY TO NAMTAB
	POP	H
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BLS1		SEE IF MORE

BLSA	DB	'SY0',200Q,200Q,200Q
BLSB	DB	0		FIRST FILE NAME FLAG
BLSC	DB	'SY0:',0		DEFAULT DEVICE
	SPACE	4,10
**	PFI - PRINT FILE INFO.
*
*	PFI DECODES A DIRECTORY ENTRY INTO A CODED LINE, THEN
*	WRITES IT TO 'DESTFB'.
*
*	THE PRODUCED FORMAT DEPENDS UPON THE LISTING FORMAT FLAG,
*	LSTA.
*
*	SHORT FORM:
*
*	NAME	.EXT	(TAB)
*
*	LONG FORM:
*
*	NAME	.EXT	SIZE	DATE	FLAGS	(NL)
*
*	ENTRY	(A) = SECTORS PER GROUP FOR THIS DEVICE
*		(DE) = DIRECTORY ENTRY POINTER
*	EXIT	IF LONG FORM, SECTOR COUNT IS ACCUMULATED IN LSTC
*	USES	ALL


PFI	STA	PFIC		SAVE SECTORS PER GROUP
	LXI	H,PFIA
	MVI	C,8
	CALL	PFI20		COPY NAME
	JZ	PFI1		ALL 8 CHARACTERS
	MVI	M,TAB
	INX	H
PFI1	MVI	M,'.'
	INX	H
	MVI	C,3
	CALL	PFI20		COPY EXTENSION
	MVI	M,TAB
	INX	H
	LDA	LSTA
	ANA	A
	JZ	PFI3		IS LONG FORM

*	IS SHORT FORM. SEE IF NEED TO END LINE

	INR	A
	CPI	5
	JNE	PFI2		NOT TIME YET
	DCX	H
	MVI	M,NL
	INX	H		TIME TO END LINE
	MVI	A,1
PFI2	STA	LSTA		RESET COUNT
	JMP	PFI6		OUTPUT TO FILE

*	IS LONG FORM.

PFI3	LXI	B,DIR.FGN-DIR.EXT-3
	XCHG			(DE) = LINE ADDR, (HL) = #PIO.DIR+DIR.EXT+3
	DAD	B		(HL) = #DIR.FGN
	LDA	NETOP
	ORA	A
	JNZ	PFI3.6
	MOV	A,M		(A) = (DIR.FGN)
	INX	H
	INX	H
	MOV	C,M		(C) = DIR.LSI = SECTORS USED IN LAST GROUP
	ERRNZ	DIR.LSI-DIR.FGN-2
	XCHG			(DE) = ADDRESS OF LSI
	PUSH	D		SAVE #DIR.LSI
	PUSH	H		SAVE LINE ADDRESS
	LHLD	LSTE
	MOV	L,A
	MOV	A,M
	CALL	CFS		COMPUTE FILE ISZE
	LDA	PFIC		(A) = SECTORS PER GROUP
	MOV	B,A						/80.06.GC/
	CALL	$MU86		(HL) = SECTORS USED (EXCEPT FOR THOSE IN LAST GROUP)

	LDA	ALLOCA						/80.06.gc/
	ANA	A						/80.06.gc/
	JZ	PFI3.5						/80.06.gc/
	MOV	C,B		Use Group Size instead if /ALL	/80.06.gc/
PFI3.5	EQU	*						/80.06.gc/

	MVI	B,0
	DAD	B		(HL) = SECTORS USED
	MOV	B,H
	MOV	C,L		(BC) = SECTORS USED COUNT
	JMP	PFI3.7
PFI3.6	EQU	*
	MOV	C,M
	INX	H
	MOV	B,M		(BC) = SECTORS USED COUNT
	INX	H		DIR.LSI
	PUSH	H		ADDRESS OF LSI
	PUSH	D		LINE ADDRESS
PFI3.7	LHLD	LSTC
	DAD	B
	SHLD	LSTC		ACCUMULATE COUNT OF SECTORS
	POP	H		(HL) = LINE ADDRESS
	MVI	A,4		3 DIGITS MAX			/80.05.gc/
	CALL	$UDDN		UNPACK COUNT
	MVI	M,TAB
	INX	H
	POP	D		(DE) = #DIR.LSI

*	TYPE DATE

	XCHG
	ERRNZ	DIR.CRD-DIR.LSI-1
	INX	H		(HL) = #DIR.CRD
	PUSH	H
	CALL	$HLIHL
	XCHG
	CALL	$DAD		DECODE AUGUSTAN DATE

*	CODE FLAGS

	XCHG			(DE) = LINE ADDRESS
	POP	H		(HL) = #DIR.CRD
	LXI	B,DIR.FLG-DIR.CRD
	DAD	B		(HL) = ADDRESS OF DIRFLG
	MOV	A,M		(A) = FLAGS
	XCHG			(HL) = LINE ADDRESS
	ANA	A
	JZ	PFI5.5		NO FLAGS
	MVI	M,TAB		TAB BEFORE FLAGS
	INX	H
	LXI	D,PFIB
PFI4	ADD	A
	JNC	PFI5		NOT SET
	PUSH	PSW		SAVE FLAGS
	LDAX	D
	MOV	M,A
	POP	PSW		RESTORE FLAGS
	INX	H
PFI5	INX	D		SET FLAG
	ANA	A
	JNZ	PFI4		MORE FLAGS SET
PFI5.5	MVI	M,NL
	INX	H

*	LINE ALL BUILT. WRITE TO DESTFB

PFI6	LXI	D,-PFIA
	DAD	D
	MOV	B,H
	MOV	C,L		(BC) = LEN
	LXI	D,PFIA		(DE) = DATA FWA
	LXI	H,DESTFB
	JMP	$FWRIB		WRITE AND EXIT
	SPACE	4,10
**	PFI20 - COPY FILE NAME.
*
*	PFI20 COPIES A NAME FILED FROM THE DIRECTORY ENTRY TO A CODED
*	LINE
*
*	EENTRY	(DE) = DIRECTORY ADDRESS
*		(C) = NAME LENGTH
*		(HL) = LINE ADDRESS
*	EXIT	(DE) = (DE) + (C)
*		'Z' SET IF MAX CHARACTERS COPIED
*	USES	A,F,C,D,E,H,L


PFI19	MOV	M,A		CORY
	INX	H
	INX	D
	DCR	C
	RZ			ALL COPIED
PFI20	LDAX	D
	ANA	A
	JNZ	PFI19		GOT CHAR

*	NO NAME. (C) = COUNT LEFT

	MOV	A,E
	ADD	C
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	ORA	E		CLEAR 'Z'
	RET

PFIA	DS	0		BUFFER AREA FOR LINE BUILD
	DB	'XXXXXXXX.YYY	NNNN	DD-MMM-YY'
	DB	'		FLAGS         '
PFIB	DB	'SLW'		CODES
PFIB1	DB	' 1234'		 ('C' FOR CONTIGUOUS IS OPTIONAL)
	ERRNZ	DIF.SYS-200Q
	ERRNZ	DIF.LOC-100Q
	ERRNZ	DIF.WP-40Q
	ERRNZ	DIF.CNT-20Q
PFIC	DB	0		SECTORS PER GROUP FOR THIS DEVICE
	STL	'ERROR PROCESSING'
	EJECT
***	VERSN	- PIP VERSION INFORMATION
*
*	DEST=/V[ERSION]
*
*	PRINT THE PIP VERSION INFORMATION TO THE 'DEST' FILE.
*

VERSN	EQU	*

	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	STC
	JNZ	ERROR		TARGET FILE SPECIFICATION ILLEGAL
	LXI	H,LINE
	CALL	$SOB		SKIP OVER ALL THE BLANKS ($DRS TURNS SWITCHES
	MOV	A,M		 TO BLANKS)
	ANA	A
	MVI	A,PEC.SFI	SOURCE FILE ILLEGAL
	STC
	JNZ	ERROR		ONLY ALLOW SWITCH ON LINE
	CALL	$TYPTX

	DB	'PIP/NET'

	DB	TAB,'Version:  '
*	DB	VERS/16+'0','.',VERS&00001111B+'0'
*	ASM has no '&' operator						/19.07.gr/
*									/19.07.gr/
	DB	VERS/16+'0','.','0'
	DB	ENL

	RET
	STL	'ERROR PROCESSING'
	EJECT
**	ERROR PROCESSING ROUTINES
*
	SPACE	3
***	NAMERR - FILE TYPE ERROR, OCCURRED ON FILE WHOSE NAME
*	IS NEXT UP IN NAMTAB.
*
*	PROCESS VIA $FERROR

NAMERR	LXI	H,NAMTAB-FB.NAM
	JMP	$FERROR
	SPACE	4
**	INTERNAL ERRORS. SHOULD NOT OCCUR.

IERR1	MVI	A,'1'
	JMP	INTERR

IERR2	MVI	A,'2'
	JMP	INTERR
IERR3	MVI	A,'3'
	JMP	INTERR


INTERR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,NL,'PIP INTERNAL ERROR ','#'+200Q
	POP	PSW
	CALL	$WCHAR
	CALL	$TYPTX
	DB	NL,'THIS ERROR SHOULD NOT OCCUR. CONTACT HEATH TECHNICAL'
	DB	NL,'CORRESPONDENCE FOR ASSISTANCE.',NL
	MVI	A,1
	DB	SYSCALL,.EXIT		ABORT
	EJECT
**	ERROR - GENERAL AND SYNTAX ERRORS NOT DIRECTLY ASSOCIATED
*	WITH A VALID FILE NAME.


ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	BELL,'ERROR -',' '+200Q
	POP	PSW
	ANA	A
	JM	ERROR1		IS PRODUCT ERROR
	MVI	H,NL		USE NL AS MESSAGE TRAIL CHAR
	DB	SYSCALL,.ERROR	LOOK UP SYSTEM ERROR
	JMP	RESTART

*	IS PRODUCT ERROR

ERROR1	LXI	H,ERRORA
ERROR2	CMP	M
	INX	H
	JNE	ERROR2		FIND ERROR MESSAGE
	DB	SYSCALL,.PRINT	PRINT MESSAGE
	JMP	RESTART

ERRORA	DS	0		ERROR MESSAGES
	DB	PEC.DF,'Device Format Error',ENL
	DB	PEC.DNC,'All Files Must Reside on the Same Device',ENL
	DB	PEC.TFI,'Destination File Specification is Illegal',ENL
	DB	PEC.CS,'Contradictory Switches Specified',ENL
	DB	PEC.IUW,'Illegal Use of Wildcard',ENL
	DB	PEC.IDF,'Illegal Destination File Format',ENL
	DB	PEC.SFI,'Source File Specification is Illegal',ENL
	LON	LGCR
	STL	'SUBROUTINES'
	EJECT
**	AEN - ADD ENTRY TO 'NAMTAB'
*
*	AEN EXPANDS THE FILE INFO IN PIO.XXX INTO A FILE DESCRIPTOR
*	AND ENTERS IT IN THE NAMTAB TABLE.
*
*	ENTRY	NONE
*	EXIT	'C' SET IF WILDCARD
*	USES	ALL


AEN	LXI	H,AENA
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	SUI	1		'C' SET IF WILDCARD
	PUSH	PSW		SAVE FLAG
	LHLD	NAMTLEN
	LXI	B,FB.NAML
	DAD	B		INCREASE SIZE
	SHLD	NAMTLEN
	XCHG			(DE) = NEW LENGTH
	LHLD	NAMTMAX
	MOV	A,L		SEE IF WILL OVERFLOW
	SUB	E
	MOV	A,H
	SBB	D
	CC	INA		INCREASE NAMTAB ALLOCATION
	LXI	H,NAMTAB-FB.NAML
	DAD	D		(HL) = *TO* ADDRESS
	LXI	D,AENA		(DE) = *FROM* ADDRESS
	CALL	$MOVE		MOVE ENTRY IN
	POP	PSW		(PSW) = WILDCARD FLAG
	RET

AENA	DS	FB.NAML
	SPACE	4,10
**	BSL - BUILD SOURCE FILE LIST.
*
*	BSL CRACKS THE LIST OF THE SOURCE FILES FROM THE COMMAND LINE AND
*	BUILDS THEM INTO THE NAMTAB MANAGED TABLE.
*	WILD CARDS ENCOUNTERED ARE EXPANDED.
*
*	ENTRY	(A) <> 0 IF TO ASK ABOUT '*.*' USE
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL


BSL	STA	BSLA		SAVE ASK FLAG
	CALL	LSN		LOCATE SOURCE NAME

*	GO THROUGH SOURCE LIST CRACKING NAMES

BSL1	MOV	A,M
	ANA	A
	RZ			ALL DONE
	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	CALL	SND		SET NEW DEFAULTS
	PUSH	H		SAVE LINE ADDRESS
	LDA	BSLA
	ANA	A
	CNZ	CCW		CHECK FOR COMPLETE WILDCARD (*.*)
	JC	RESTART		USER CHICKENED OUT		/79.12.GC/
	CALL	EWS		EXPAND WILDCARD SPECIFICATION
BSL2	POP	H		RESTORE LINE ADDRESS
	RC			USER REFUSED *.*
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BSL1		DO MORE

BSLA	DB	0		<>0 IF TO CHECK FOR *.*
	SPACE	4,10
**	CCW - CHECK FOR COMPLETE WILDCARD.
*
*	CCW IS CALLED WITH A NAME CRACKED INTO PIO.XXX, TO SEE IF
*	IT IS A *.* SPECIFICATION.
*
*	IF SO, CCW ASKS,
*
*	DELETE ALL FILES ON DEV: ?!? (Y/N)
*
*	THE USER REPLY IS ACCEPTED AND DECODED.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF NOT *.*, OR 'Y' REPLIED
*		'C' SET IF *.* AND NOT 'Y'
*	USES	A.F,B,H,L


CCW	LXI	H,PIO.DIR+DIR.NAM
	MVI	B,8+3
	MVI	A,200Q
CCW1	ANA	M		SEE IF ALL HAVE 200Q BIT SET
	INX	H
	DCR	B
	JNZ	CCW1
	ANA	A
	RP			NOT *.*

*	IS *.*

	CALL	$TYPTX
	DB	BELL,'!?! DELETE ALL FILES ON',' '+200Q
	LXI	H,PIO.DEV
	MVI	A,3
	CALL	$TYPCC		TYPE DEVICE NAME
	CALL	$TYPTX
	DB	': (Y/N)?',' '+200Q
	LXI	H,DESTBUF
	CALL	$RTL.		READ REPLY
	LDA	DESTBUF
	CPI	'Y'
	RE			IS OK
	STC
	MVI	A,PEC.IUW	FLAG ILLEGAL USE OF WILDCARD
	RET			FORGET IT
	SPACE	4,10
**	CFE - CHECK FILE ELIGIBILITY.
*
*	CFE CHECKS TO SEE IF A WILDCARD-SELECTED FILE IS ELIGIBLE
*	FOR PROCESSING. IF THE FILE IS FLAGGED SYSTEM, AND /S IS NOT
*	SPECIFIED, THE FILE IS NOT ELIGIBLE.
*
*	ENTRY	(HL) = DIRECTORY ENTRY POINTER
*	EXIT	'Z' SET IF ELIGIBLE
*	USES	A,F


CFE	PUSH	H
	MVI	A,DIR.FLG
	CALL	$DADA.
	MOV	A,M		(A) = FLAG
	ANI	DIF.SYS
	POP	H
	RZ			ELIGIBLE
	LDA	SYSTEM		CHECK /S FLAG
	ANA	A
	RET
	SPACE	4,10
**	CFS - COMPUTE FILE SIZE
*
*	CFS COMPUTES THE SIZE OF A FILE. THE DEVICE'S GRT MUST BE IN
*	THE 'GRT' BUFFER.
*
*	ENTRY	(A) = FIRST GROUP NUMBER
*	EXIT	(DE) = SIZE
*	USES	ALL


CFS	LHLD	LSTE
CFS.	LXI	D,0
CFS1	ANA	A
	RZ			ALL DONE
	MOV	L,A
	MOV	A,M		(A) = NEXT GRT
	INX	D
	JMP	CFS1		TRY AGAIN
	SPACE	4,10
**	CTS	-  CHECK TARGET FILE SPECIFICATION
*
*	CTS CHECKS FOR A TARGET FILE SPECIFICATION
*
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= 'Z' SET IF NO TARGET FILE
*			= 'Z' CLEAR IF    TARGET FILE
*			   (A)  = PEC.TFI ERROR CODE
*
*	USES	(PSW),(HL)
*

CTS	CALL	LSN		(HL) = ADDRESS OF FIRST SOURCE NAME
	LXI	D,-LINE
	DAD	D		(HL) == 0 IF NO '=' IN COMMAND LINE
	MOV	A,L
	ORA	H
	RZ			NO TARGET FILE
	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	RET			TARGET FILE SPECIFIED
	SPACE	4,10
**	CWM - CHECK WILDCARD MATCH.
*
*	CWM CHECKS TO SEE IF A WILDCARDED FIELD MATCHES A NON-WILDCARDED
*	FIELD.
*
*	ENTRY	(DE) = ADDRESS OF WC NAME
*		(HL) = ADDRESS OF NON/WC NAME
*		(B) = NUMBER OF CHARACTERS TO CHECK
*	EXIT	'Z' SET IF MATCH
*		 (HL) = (HL)+(B)
*		 (DE) = (DE) = (B)
*		'Z' CLEAR IF NO MATCH
*	USES	A,F,B,D,E,H,L


CWM	LDAX	D
	ANA	A
	JM	CWM1		IS MATCH
	CMP	M
	RNE			NO MATCH
CWM1	INX	D
	INX	H		ADVANCE ADDRESSES
	DCR	B
	JNZ	CWM		GO FOR MORE
	RET			GOT MATCH
	SPACE	4,10
**	DDF - DECODE DESTINATION FILE.
*
*	DDF DECODES THE DESTINATION FILE NAME FROM THE COMMAND LINE.
*
*	IF NO DESTINATION NAME IS SPECIFIED, IT DEFAULTS TO
*
*	KB:PIPDEST.JGL
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF OK
*		 (A) = 0 IF NAME HAS WILDCARDS
*		 (A) = 1 IF NO WILDCARD USED
*		 DESTFB+FB.NAM CONTAINS A COMPLETE DESTINATION FILE NAME
*		 (HL) = COMMAND LINE POINTER UDPATED
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL


DDF	LXI	D,LINE
	MOV	H,D
	MOV	L,E		(HL) = COMMAND POINTER
DDF1	LDAX	D
	INX	D
	CPI	'='
	JE	DDF2		HAVE A SOURCE FILE
	ANA	A
	JNZ	DDF1		MORE TO CHECK
DDF1.0	LXI	H,DDFA		USE DEFAULT

*	(HL) = ADDRESS FOR NAME

DDF2	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	JZ	DDF1.0		NO FILE NAME SPECIFIED, USE DEFAULT
	MOV	A,M
	CPI	'='
	MVI	A,PEC.IDF	ASSUME ILLEGAL DESTINATION FORMAT
	STC
	RNE			MUST HAVE '='

*	HAVE NAME DECODED. EXPAND INTO DESTFB+FB.NAM

	LXI	H,DESTFB+FB.NAM
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT

DDFA	DB	'TT:PIPDEST.JGL=',0
	SPACE	4,10
**	CAD - CONVERT ASCII FILE NAME INTO DIRECTORY FORMAT.
*
*	CAD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
*
*	DEV:NAME.EXT
*
*	INTO THE PIO.XXX FIELDS.
*
*	THE DEFAULT BLOCK DETERMINES THE VALUES FOR THE DEVICE AND EXTENSION
*	FIELDS, IF THEY ARE UNSPECIFIED. IF *CAD* IS ENTERED
*	AT *CAD*, AN UNSPECIFIED NAME FIELD IS RETURNED AS ZERO BYTES.
*	IF ENTERED AT *CAD.*, AN UNSPECIFIED NAME FIELD IS
*	RETURNED AS 200Q (MATCH-ONE) BYTES.
*
*	ENTRY	(DE) = POINT TO DEFAULT BLOCK
*		(HL) = POINTER TO TEXT
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		 (HL) = POINTS PAST FILE NAME
*		 'Z' SET IF NULL NAME
*		 'Z' CLEAR IF NON-NULL
*		  PIO.DIR.NAM = NAME
*		  PIO.DIR.EXT = EXTENSION
*		  PIO.DEV = DEVICE CODE
*		  PIO.UNI = UNIT NUMBER (ASCII DIGIT)
*	USES	ALL


CAD	XRA	A		SET TO NULLS
	JMP	CAD0

CAD.	MVI	A,200Q
CAD0	PUSH	H
	STA	CADA		SAVE DEFAULT VALUE

*	SET DEFAULTS IN PIO.xxx

	LXI	H,PIO.DEV
	LXI	B,3
	CALL	$MOVE		SET DEFALUT DEVICE
	LXI	B,3
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		SET DEFAULT EXTENSION
	POP	H
	CALL	$SOB		SKIP BLANKS
	MVI	B,0
	CPI	'?'
	JE	CAD1		IS '?'
	CPI	'*'
	JE	CAD1		IS '*'
	CPI	'.'
	JE	CAD1		IS '.'
	CPI	'A'
	JC	CAD4		NOT NAME
	CPI	'Z'+1
	JNC	CAD4		NOT NAME

*	HAVE ALPHA STRING. CRACK IT

CAD1	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR
	CPI	':'
	JNE	CAD2		NOT DEVICE

*	HAVE EXPLICIT DEVICE

	INX	H		SKIP '1'
	MVI	A,3
	CMP	C
	JC	CAD5		TOO MANY CHARACTERS
	MVI	A,PIO.UNI-PIO.DEV-1					/2.0b/
	CMP	C							/2.0b/
	JNC	CAD5		Too Few characters			/2.0b/

	MVI	A,'0'							/2.0b/
	STA	PIO.UNI		Assume Unit 0				/2.0b/
	MVI	B,0		BC = Move Count				/2.0b/
	PUSH	H		SAVE (HL)
	LXI	H,PIO.DEV
	CALL	$MOVE		SET EXPLICIT DEVICE
	POP	H
	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR

*	DECODE NAME

CAD2	LXI	B,8		(BC) = COUNT
	PUSH	H		SAVE TEXT ADDR

*	SEE IF NAME IS  UNSPECIFIED

	LXI	H,PIO.DIR+DIR.NAM
	PUSH	H		SAVE ADDRESS OF DIR.NAM
	CALL	$MOVE		MOVE IN NAME
	POP	H		(HL) = #PIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JNZ	CAD2.6		IS SPECIFIED
	LDA	CADA		(A) = FILL CHARACTER
	MVI	C,8		(C) = COUNT
CAD2.4	MOV	M,A
	INX	H
	DCR	C
	JNZ	CAD2.4
CAD2.6	POP	H
	MOV	A,M		(A) = DELIMITER
	CPI	'.'
	JNE	CAD3		NOT EXTENSION

*	HAVE EXPLICIT EXTENSION

	INX	H
	CALL	DNT
	JC	CAD5		ERROR
	MVI	A,3
	CMP	C
	JC	CAD5		TOO LONG
	LXI    B,3
	PUSH	H		SAVE TEXT POINTER
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		MOVE EXTENSION
	POP	H

*	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

CAD3	MVI	B,1		(B) = NAME PRESENT FLAG

*	END OF NAME. EXIT
*	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

CAD4	CALL	$SOB		SKIP BLANKS
	MOV	A,M		(A) = NEXT CHARACTER
	CALL	$CFD		CHECK FILE NAME DELIMITER
	RC			ERROR
	MOV	A,B
	ANA	A		SET 'Z' IF NULL
	RET

*	ERROR

CAD5	MVI	A,EC.IFN	ILLEGAL FILE NAME
	STC
	RET

CADA	DB	0		FILL CHARACTER FOR OMITTED NAME FIELD
	SPACE	4,10
**	DNT - DECODE NEXT TOKEN.
*
*	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
*
*	ENTRY	(HL) = TEXT POINTER
*	EXIT	'C' SET IF ERROR
*		'C' CLEAR IF OK
*		(A] = DELIMTER CHARACTER
*		(HL) UPDATED TO DELIMITER CHARACTER
*		(DNTA) = STRING
*		(C) = LENGTH
*		(DE] = #DNTA
*	USES	ALL


DNT	LXI	D,DNTA
	MVI	C,9		(C) = SIZE OF DNTA
	MOV	B,C		(B) = MAX ALLOWED +1
	XRA	A
DNT1	STAX	D		ZERO BUFFER
	INX	D
	DCR	C
	JNZ	DNT1
	LXI	D,DNTA

*	COPY CHARACTERS

DNT2	MOV	A,M
	CPI	'?'
	MVI	A,200Q
	JE	DNT3		IS MATCHONE
	MOV	A,M
	CPI	'*'
	JE	DNT5		IS WILDCARD
	CPI	'0'
	JC	DNT4		NOT ALPHANUMERIC
	CPI	'9'+1
	JC	DNT3		NUMERIC
	CPI	'A'
	JC	DNT4		DELIMITER
	CPI	'Z'+1
	JNC	DNT4		DELIMITER

*	HAVE GOOD CHARACTER

DNT3	STAX	D		STORE CHAR
	INX	D
	INX	H
	INR	C		COUNT
	DCR	B		LIMIT DECREMENT
	JNZ	DNT2		NOT OVERFLOW

*	OVERFLOW

	STC			FLAG ERR
	RET

*	IS '*' WILDCARD

DNT5	MVI	A,200Q
	STAX	D
	INX	D
	DCR	B
	JNZ	DNT5		FILL WITH MATCH ONE
	INX	H		SKIP '*'

*	END OF STRING

DNT4	ANA	A		CLEAR 'C'
	LXI	D,DNTA		SET POINTER
	RET

DNTA	DS	9		WORK AREA
	SPACE	4,10
**	EBM - EXPAND BUFFER TO MAXIMUM.
*
*	EBM IS CALLED TO EXPAND THE BUFFER 'BUF' TO THE MAXIMUM SIZE.
*	WHICH DOES NOT REQUIRE THE OVERLAYING OF THE SYSTEM.
*
*	ENTRY	NONE
*	EXIT	(BUFSIZ) = BUFFER SIZE (MULTIPLE OF 256)
*	USES	ALL


EBM	LHLD	S.SYSM
	PUSH	H
	LHLD	S.OFWA
	LXI	D,OVL0*OVL.ENS+OVL.FLB
	DAD	D		(HL) = ADDR. OF OVL0 OVL.FLB ENTRY
	MVI	A,OVL.RES
	ANA	M
	LXI	D,OVL.ENS
	DAD	D		(HL) = ADDR. OF OVL1 OVL.FLB ENTRY
	ERRNZ	OVL1-OVL0-1
	ANA	M
	JNZ	EBM1		OVL0 AND OVL1 ARE PERM. RESIDENT
	LHLD	S.OMAX
	CALL	$CHL
	XCHG
	POP	H
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	PUSH	H

EBM1	POP	H
	LXI	D,-6
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	DB	SYSCALL,.SETTP
	JC	IERR1		INTERNAL ERROR 1
	LHLD	S.USRM
	XCHG
	LHLD	BUFPTR
	CALL	$CHL		(HL) = - BUFFER FWA
	DAD	D
	MVI	L,0
	SHLD	BUFSIZ
	MVI	A,BUFMINL/256-1
	CMP	H
	RC			IF OK
	MVI	A,EC.NEM
	JMP	ERROR		NOT ENOUGH MEMORY

	SPACE	4,10
**	CDA - CONVERT DIRECTORY FORMAT TO ASCII.
*
*	CDA COPIES A DIRECTORY ENTRY FROM PIO.XXX TO A TARGET FIELD.
*	THE DEVICE SPECIFICATION (IN PIO.DEV AND PIO.UNI) IS ALSO ENCODED.
*	THE TARGET FIELD IS LEFT IN THE FORM:
*
*	DEV:NAME.XXX <00>
*
*	ENTRY	(HL) = FWA NAME FIELD
*	EXIT	(A) = 0, HAVE WILDCARD
*		    = 1, NO WILDCARDS USED
*		'C' CLEAR
*	USES	ALL


CDA	LXI	B,3*256		(B) = CHARACTER COUNT, (C) = WILDCARD FLAG
	LXI	D,PIO.DEV
	CALL	CDA5		COPY IT
	MVI	M,':'
	INX	H
	MVI	B,8
	LXI	D,PIO.DIR+DIR.NAM
	CALL	CDA5		COPY IT
	MVI	M,'.'
	INX	H
	MVI	B,3
	ERRNZ	DIR.EXT-DIR.NAM-8
	CALL	CDA5		COPY IT
	MVI	M,0		FLAG END OF NAME
	MOV	A,C		(A) (BIT 7) = 1 IF WILDCARDS
	RLC
	CMA
	ANI	1		=0 IF WILDCARD
	RET
	SPACE	2
**	CDA5 - CONVERT DIRECTORY FIELD TO ASCII.
*
*	ZEROS ARE IGNORED, 200Q WILDCARDS ARE MAPPED TO '?'
*
*	ENTRY	(DE) = FROM
*		(HL) = T0
*		(B) = COUNT
*		(C) = ORA ACCUMULATOR
*	EXIT	(DE) ADVANCED
*		(HL) = (HL)+(B)
*		(C) = (C) .OR. (FROM CHARACTERS PROCESSED)
*	USES	ALL


CDA5	LDAX	D		(A) = CHARACTER
	ORA	C
	MOV	C,A
	LDAX	D
	INX	D
	ANA	A
	JZ	CDA7		IS 00
	JP	CDA6		NOT 200Q
	MVI	A,'?'
CDA6	MOV	M,A
	INX	H		INCREMENT TO
CDA7	DCR	B
	JNZ	CDA5		IF MORE TO GO
	RET
	SPACE	4,10
**	EWS - EXPAND WILDCARD SPECIFICATION.
*
*	DWS ENTERS THE FILE NAME IN PIO.XXX INTO THE MANAGED TABLE
*	NAMTAB. IF THE FILE NAME CONTAINS WILDCARDS, THE DIRECTORY
*	IS READ FOR ELIGIBLE FILES.
*
*	ENTRY	PIO.XXX = FILE NAME
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*	USES	ALL


EWS	CALL	AEN		TRY TO ENTER IT
	RNC			NO WILDCARDS, AM DONE

*	IS WILDCARD. LOOK UP DEVICE TYPE

	LHLD	NAMTLEN
	LXI	D,NAMTAB-FB.NAML
	DAD	D		(HL) = ADDRESS OF LAST ENTRY
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D
	SHLD	NAMTLEN		REMOVE WILDCARD FROM TABLE
	CALL	$MOVEL
	DW	3,PIO.DEV,DIRNAM	SET DIRECTORY NAME IN XXX:DIRECT.SYS
	CALL	$MOVEL
	DW	8+3,PIO.DIR+DIR.NAM,EWSC	SAVE WILDCARD PATTERN
	LXI	B,EWSB
	LXI	H,DIRNAM
	DB	SYSCALL,.DECODE GET INFORMATION ABOUT DEVICE
	RC			ERROR
	LDA	EWSB		SEE IF A DIRECTORY DEVICE
	ANI	DT.DD+DT.RN
	CPI	DT.RN
	JZ	EWSNET
	ANI	DT.DD
	MVI	A,EC.DNS		ASSUME DEVICE NOT SUITABLE
	STC
	RZ			ERROR

*	IS DIRECTORY DEVICE. OPEN DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	DB	SYSCALL,.OPENR
	MVI	A,PEC.DF
	RC			DEVICE FORMAT FAILURE

*	READ DIRECTORY ENTRYS FOR MATCH

EWS1	CALL	GDWP		DE = DIRECTORY WORKSPACE PTR	/79.11.GC/
	LXI	B,512
	MVI	A,CN.DIR
	PUSH	D		SAVE ADDRESS
	DB	SYSCALL,.READ	READ BLOCK
	POP	H		(HL) = DIRECTORY ADDRESS
	JC	EWS7		ALL DONE

*	LOOK AT DIRECTORY BLOCK FOR MATCHES

	PUSH	H						/79.11.GC/
	CALL	GDWP.						/79.11.GC/
	CALL	$INDLB						/79.11.GC/
	DW	DIS.ENL		A  = DIRECTORY ENTRY LENGTH	/79.11.GC/
	POP	H						/79.11.GC/

	MOV	C,A		(C) = LENGTH

*	CHECK NEXT ENTRY

EWS3	MOV	A,M		(A) = 1ST CHAR THIS ENTRY
	ANA	A
	JZ	EWS1		END OF BLOCK
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	EWS6		ENTRY EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	JZ	EWS7		END OF LIST
	CALL	CFE		CHECK FOR FILE ELIGIBILITY
	JNZ	EWS6		NOT TO PROCESS
	PUSH	H
	LXI	D,EWSC
	MVI	B,8+3
	CALL	CWM		CHECK WILDCARD MATCH
	JNZ	EWS4		NO MATCH

*	HAVE MATCH. ADD TO LSIT

	POP	D		(DE) = FROM
	PUSH	D
	PUSH	B		SAVE (C)
	LXI	B,8+3
	LXI	H,PIO.DIR+DIR.NAM
	CALL	$MOVE
	CALL	AEN		ADD TO TABLE
	POP	B		RESTORE (C)

*	LOOKUP NEXT ENTRY

EWS4	POP	H
EWS6	MVI	B,0
	DAD	B		POINT TO NEXT
	JMP	EWS3

*	ALL DONE. CLOSE DIRECTORY FILE

EWS7	MVI	A,CN.DIR
	DB	SYSCALL,.CLOSE
	RET

EWSA	DB	'SY0',200Q,200Q,200Q

EWSB	DS	30

EWSC	DS	8+3		WILDCARD PATTERN FOR DIRECTORY SEARCH
	SPACE	4,10
**	GDWP	-  GET DIRECTORY WORKSPACE POINTER		/79.11.GC/
*
*	GDWP GETS THE DIRECTORY WORKSPACE POINTER
*
*	ENTRY:	NONE
*
*	EXIT:	DE	= DIRECTORY WORKSPACE POINTER
*
*	USES:	DE
*

GDWP	XCHG
	CALL	GDWP.		HL = DIRECTORY WORKSPACE POINTER
	XCHG
	RET

GDWP.	LHLD	S.SCR		HL = SYSTEM SCRATCH
	RET
	SPACE	4,10
**	INA - INCREASE NAMTAB ALLOCATION.
*
*	INA IS CALLED TO INCREASE THE NAMTAB ALLOCATION. THE
*	BUFFER AREA IS MOVED UP TO MAKE ROOM.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,H,L

INA	LXI	H,NAMTMAX+1
	INR	M		INCREMENT LENGTH
	LXI	H,BUFPTR+1
	INR	M		MOVE BUFFER
	LHLD	BUFSIZ
	MOV	A,H
	ORA	L
	MVI	A,EC.NEM	FLAG OUT OF MEMORY IF BUFFER NOT EMPTY
	JNZ	ERROR
	PUSH	B
	PUSH	D
	CALL	SBE		NOTIFY SYSTEM
	POP	D
	POP	B
	RET
	SPACE	4,10
**	LSN - LOCATE SOURCE NAME
*
*	LSN SCANS THE COMMAND LINE FOR THE FIRST SOURCE FILE NAME.
*
*	ENTRY	NONE
*	EXIT	(HL) = 1ST FILE NAME FWA
*	USES	A,F,H,L

LSN	LXI	H,LINE
LSN1	MOV	A,M
	INX	H
	CPI	'='
	RE			GOT IT
	ANA	A
	JNZ	LSN1		MORE LINE
	LXI	H,LINE	IS NO =
	RET
	SPACE	4,10
**	MWN - MERGE WILDCARD NAMES.
*
*	MWN MERGES A COMPLETELY SPECIFIED FILENAME WITH A WILDCARDED COMPLETELY
*	SPECIFIED FILE NAME.
*
*	BOTH FILE NAMES SHOULD HAVE THE SAME DEVICE SPECIFICATION.
*
*	FILE NAME FORMAT:
*
*	DEV:NAMEXXXX.EXT 00
*
*	ENTRY	(BC) = ADDRESS OF WILDCARDED ASCII NAME
*		(DE) = ADDRESS OF NON-WC ASCII NAME
*		(HL) = ADDRESS FOR RESULTANT ASCII NAME
*	EXIT	NONE
*	USES	ALL


MWN	PUSH	H		SAVE TARGET ADDRESS
	PUSH	B		SAVE WC PATTERN
	XCHG			(HL) = MASTER NAME
	CALL	CAD		CONVERT TO DIRECTORY FORMAT
	CALL	$MOVEL
	DW	8+3,PIO.DIR,MWNA	(MWNA) = DECODED MASTER
	POP	H		(HL) = WC PATTERN
	CALL	CAD		(PIO.DIR) = WC PATTERN
	LXI	D,MWNA		(DE) = MASTER PATTERN
	LXI	H,PIO.DIR	(DE) = WC PATTERN ADDRESS
	MVI	C,8+3		MERGE NAME AND EXTENSION

*	MERGE NAMES

MWN1	MOV	A,M		(A) = WC PATTERN
	ANA	A
	JP	MWN2		USE THIS
	LDAX	D		IS MATCH CHARACTER, USE MASTER INSTEAD
MWN2	MOV	M,A		STORE CHARACTER
	INX	D
	INX	H
	DCR	C
	JNZ	MWN1		MERGE TILL DONE
	POP	H		(HL) = TARGET ADDRESS
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
	SPACE	4,10
**	REN - REMOVE ENTRY FROM *NAMTAB*
*
*	REN REMOVES THE FIRST 'FB.NAML' BYTES FROM NAMTAB.
*
*	THE AMOUNT (FB.NAML) IS REMOVED FROM THE SIZE OF THE TABLE. THE
*	TABLE IS NOT CHECKED FOR UNDERFLOW, THE CALLER MUST GUARANTEE THE
*	PRESENSE OF AT LEAST FB.NAML BYTES IN NAMTAB.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


REN	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D		REMOVE COUNT FROM LEN
	SHLD	NAMTLEN
	MOV	B,H
	MOV	C,L		(BC) = REMAINING LENGTH
	LXI	D,NAMTAB+FB.NAML	(DE) = START OF 2ND ENTRY
	LXI	H,NAMTAB
	JMP	$MOVE		MOVE DOWN AND RETURN
	SPACE	4,10
**	SBE - SET BUFFER EMPTY.
*
*	THE SYSTEM IS NOTIFIED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


SBE	LXI	H,0
	SHLD	BUFSIZ
	LHLD	BUFPTR		(HL) = BUFFER FWA (AND LWA!)
	INX	H
	INX	H
	DB	SYSCALL,.SETTP
	RNC			OK
	JMP	ERROR		NOT ENOUGH ROOM
	SPACE	4,10
**	SDD - SET DEFAULT DEFAULT.
*
*	SDD IS CALLED TO SETUP THE CURRENT DEFAULT DEVICE
*	AND EXTENSION TO 'SY0' AND <NULL>, RESPECTIVELY.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE


SDD	CALL	$SAVALL
	CALL	$MOVEL
	DW	6,SDDA,DEFALT	SET DEFAULT DEFAULT
	JMP	$RSTALL		RESTORE AND RETURN

SDDA	DB	'SY0',0,0,0	DEFAULT DEFAULT VALUES
	SPACE	4,10
**	SFS - SKIP FILE SEPERATOR.
*
*	SFS IS CALLED TO SKIP OVER THE CHARACTERS SEPERATING ONE
*	FILE NAME FROM ANOTHER ON THE LINE. THE FILES MAY BE SEPERATED
*	BY BLANKS OR A COMMA ALONE, OR BY BLANKS WITH A COMMA. THE
*	SYNTAX IS
*
*	<BLANKS> <,> <BLANKS>
*
*	ONE. TWO OR ALL THREE FIELDS MAY BE PRESENT.
*
*	ENTRY	(HL) = POINT TO START OF SEP FIELD
*	EXIT	(HL) ADVANCED PAST SEPERATOR FIELD
*	USES	A,F,H,L


SFS	CALL	$SOB		SKIP BLANKS
	MOV	A,M
	CPI	','
	JNE	SFS1		NOT ,
	INX	H		SKIP ,
SFS1	JMP	$SOB		GET ANY MORE BLANKS AND EXIT
	SPACE	4,10
**	SND - SET NEW DEFAULTS.
*
*	SND lS CALLED TO SET A NEW DEFAULT DEVICE AND EXTENSION
*	IN THE 'DEFALT' AREA.
*
*	ENTRY	PIO.DEV = DEVICE CODE
*		PIO.UNI = UNIT #
*		PIO.DIR+DIR.EXT = EXTENSION
*	EXIT	NONE
*	USES	NONE


SND	CALL	$SAVALL		SAVE REGS
	ERRNZ	PIO.UNI-PIO.DEV-2
	CALL	$MOVEL
	DW	3
	DW	PIO.DEV
	DW	DEFALT
	CALL	$MOVEL
	DW	3
	DW	PIO.DIR+DIR.EXT
	DW	DEFALT+3
	JMP	$RSTALL		RETURN
	STL	'COMMON DECKS'
	EJECT
	XTEXT	CFD
	XTEXT	TYPCC
	XTEXT	WER
	XTEXT	ZERO
	XTEXT	MU86
	XTEXT	CCO
	XTEXT	GNL
	XTEXT	MLU
	XTEXT	MCU
	XTEXT	RTL
	XTEXT	MOVE
	XTEXT	CHL
	XTEXT	SOB
	XTEXT	TBLS
	XTEXT	DADA
	XTEXT	TJMP
	XTEXT	CRLF
	XTEXT	TYPCH
$CMP$	EQU	1
	XTEXT	TYPLN
	XTEXT	TYPT2
	XTEXT	COMP
	XTEXT	SAVALL
	XTEXT	CDEHL
	XTEXT	UDD
	XTEXT	DU66
	XTEXT	DADA2
	XTEXT	HLIHL
	XTEXT	ILDEHL
	XTEXT	INDL
	XTEXT	INDXX
	XTEXT	ISDEHL
	XTEXT	DAD
	XTEXT	UDDN
	XTEXT	MOVEL
	XTEXT	RCHAR
	XTEXT	XCHGBC
	XTEXT	DRS
	XTEXT	DTB
	XTEXT	FOPE
	XTEXT	FWRIB
	XTEXT	FCLO
	XTEXT	FUTIL
	STL	'ONECOPY SPECIAL DATA STRUCTURES'
	EJECT
PATCH	DS	64		PATCH AREA
	STL	'ONECOPY SPECIAL DATA STRUCTURES'
	EJECT

*	; APPEARS HERE TO ALLOW FDN. TO BE IN ONE PAGE
	XTEXT	FERROR

	STL	'PRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
ALLOCA	DB	0		/ALL flag (<>0 if /ALL specified) /80.06.gc/
COMAND	DB	0		COMMAND IN PROGRESS
MODE	DB	0		<>0 IF LINE PASSED ON STACK
JGL	DB	0		/JGL FLAG (<>0 IF /JGL SPECIFIED,
SUPRES	DB	0		/SUP FLAG (<>0 OF /SUP SPECIFIED)
SYSTEM	DB	1		/S FLAG (=0 IF /S SPECIFIED)

DIRNAM	DB	'XXX:DIRECT.SYS',0	DIRECTORY FILE NAME

BUFPTR	DW	BUFF		POINTER TO START  OF BUFFER
BUFSIZ	DW	0		BUFFER LENGTH
	SPACE	3
**	FILE BLOCKS

DESTFB	DS	0		DESTINATION FILE BLOCK
	DB	CN.DES		CHANNEL NUMBER
	DB	0		FLAGS
	DW	DESTBUF
	DW	DESTBUF
	DW	DESTBUF
	DW	DESTBFE		END OF BLOCK
	DS	FB.NAML		NAME AREA
	SPACE	3
NAMTLEN DW	0		NAME TABLE POINTER
NAMTMAX DW	0		MAXIMUM SIZE OF NAME TABLE

* HL = fully-qualified filename (always has device prefix).
* BC = fully-qualified filename?
RENNET	EQU	*
	PUSH	B
	LXI	B,LSTD		OLD NAME
	DB	SYSCALL,.DECODE
	POP	H
	JC	ERROR
	LXI	B,EWSB		NEW NAME
	DB	SYSCALL,.DECODE
	JC	ERROR
	LXI	D,EWSB		NEW NAME
	LXI	H,LSTD		OLD NAME
	MVI	C,.RENAM
	CALL	NETCALL
	JC	ERROR
	JMP	REN6

* HL = fully-qualified filename (always has device prefix).
* Do a QUICK check for network device, return NZ if not.
* Else try to pass to network device driver.
* Return CY on network device error,
* NZ if not a network device file string.
DELNET	EQU	*
*	TODO... doing this brute-force, but performance
*	is probably not critical. ideally, EWSNET would
*	store the ambiguoous file spec instead of expanding
*	it, since the network server handles deletes with
*	wildcards. But that changes the NAMTAB semantics
*	and requires more code changes.
	PUSH	H
	LXI	B,LSTD
	DB	SYSCALL,.DECODE
	LDA	LSTD+0
	ANI	DT.DD+DT.RN
	CPI	DT.RN
	STC
	CMC			MUST GET NZ and NC
	JNZ	NDEL1		NOT A NETWORK DEVICE
	LHLD	LSTD+17		(HL) = DEV TBL ADDR
	CALL	SETNET		SETUP NET DEV FROM DTA
	LXI	H,LSTD+1
	MVI	C,.DELET
	CALL	NETCALL
	POP	H
	RC
	XRA	A
	RET
NDEL1	POP	H
	RET

* Commands taking wildcards (/COPY, /RENAME, /DELETE) use this
EWSNET	EQU	*
	LHLD	EWSB+17		DTA
	CALL	SETNET		SETUP NET DEV FROM DTA
*	TODO
	MVI	C,.SERF
	LXI	H,PIO.DEV
NEWS6	LXI	D,PIO.DIR	DE = TARGET DIR ENT
	CALL	NETCALL		C = OP (SERF/SERN)
	JC	NEWS9		CHECK EC.EOF
	LXI	H,PIO.DIR
	CALL	CFE		CHECK FILE ELIGIBILITY
	JNE	NEWS7		NOT ELIGIBLE
	CALL	AEN		ADD TO TABLE
NEWS7	MVI	C,.SERN
	JMP	NEWS6
NEWS9	EQU	*
	CPI	EC.EOF
	JNZ	ERROR
*	TODO
	RET		RET TO CALLER OF EWS

* /LIST (et al.) on a Networked Device
*	HL = Device Table Address (DEV.NAM)
LSTNET	EQU	*
	CALL	SETNET		SETUP NET DEV FROM DTA

	CALL	LSTSUP		DO REST OF SETUP
*	Work through all file expressions
	LXI	H,NAMTAB
NLST5	PUSH	H		SAVE ADDRESS OF FILE PATTERN
	LXI	D,LSTD		OR DIRNAM? OR?
	CALL	CAD		CONVERT ASCII NAMTAB ENTRY TO DIRECTORY FORMAT
*	get entry from remote server... search first
	MVI	C,.SERF
	LXI	H,PIO.DEV
NLST6	CALL	GDWP		DE = WORKSPACE
	CALL	NETCALL		C = OP (SERF/SERN)
	JC	NLST9		CHECK EC.EOF
	CALL	GDWP.		HL = WORKSPACE
	CALL	CFE		CHECK FILE ELIGIBILITY
	JNE	NLST7		NOT ELIGIBLE
	CALL	GDWP		DE = WORKSPACE
	CALL	PFI		PRINT FILE AND INFO
	LXI	H,LSTB
	INR	M		COUNT FILE
*	; search next...
NLST7	MVI	C,.SERN
	JMP	NLST6
NLST9	POP	H		CURRENT NAMTAB ENTRY
	CPI	EC.EOF
	JNZ	ERROR
*	NEXT FILE, IF ANY
	LXI	B,FB.NAML
	DAD	B		ADVANCE PAST ENTRY IN NAMTAB
*	SEE IF AT END OF NAMTAB
	PUSH	D
	XCHG			(DE) = NEW ADDRESS
	LHLD	NAMTLEN
	LXI	B,NAMTAB
	DAD	B		(HL) = LWA+1 OF TABLE
	XCHG
	CALL	$CDEHL		COMPARE
	POP	D
	JNE	NLST5		MORE IN TABLE
	JMP	LIST9.1		CONTINUE WITH SUMMARY

*	HL = device table address (DEV.NAM)
* Also check DEV.RES for DR.IM and call DC.LOD if not
SETNET	EQU	*
	MVI	A,1
	STA	NETOP
	INX	H
	INX	H		DEV.RES
	MOV	A,M
	INX	H		DEV.JMP
	SHLD	NETJMP
	ANI	DR.IM
	MVI	A,DC.LOD
	CZ	NETCL0
	RET

NETCALL	MVI	A,DC.DSF
NETCL0	PUSH	H
	LHLD	NETJMP
	XTHL
	RET

NETJMP	DW	0
NETOP	DB	0

*	SETUP FOR FILE LIST COMMANDS
LSTSUP	EQU	*
*	OPEN OUTPUT FILE

	LXI	H,DESTFB
	CALL	$FOPEW		OPEN FOR WRITE

*	GENERATE HEADING

	LXI	B,1		(BC) = TEXT COUNT
	LXI	D,LSTG		(DE) = TEXT ADDRESS
	LDA	LSTA
	ANA	A
	JNZ	LIST2		IS SHORT
	MVI	C,LSTGL		PRINT FULL HEADING
LIST2	CALL	$FWRIB		WRITE HEADING
	RET

	LON	LGCR
	STL	'RRS - PRESET PROGRAM (OVERLAID BY BUFFERS).'
	EJECT
***	PRS - PRESET PIP PROGRAM.
*
*	PRS IS CALLED TO PERFORM ONE-TIME-ONLY PRESETTING OF
*	THE PROGRAM ENVIRONMENT.
*
*	THE CODE IS OVERLAID BY BUFFERS AND WORK AREAS WHEN PIP IS RUNNING.
*	BE CAREFUL NOT TO USE ANY OF THE BUFFERS AND WORK AREAS BEFORE
*	THE AREA *LINE*.
*
*
*	ENTRY	NONE
*
*	EXIT	IF  CORRECT VERSION OF HDOS
*		    NONE
*		  ELSE
*		    EXIT TO HDOS
*
*	USES	ALL
*

ENTRY	EQU	*		INITIAL ENTRY POINT
PRS	DB	SYSCALL,.VERS
	JC	PRS1		ERROR IN GETTING VERSION
	CPI	VERS
	JNZ	PRS1		NOT CORRECT VERSION OF HDOS
	LXI	H,RMEML		(HL) = RUN-TIME HIGH MEMORY
	DB	SYSCALL,.SETTP	SET HI MEMORY
	JC	PRS2		IF  ERROR
	LXI	H,CCHIT
	MVI	A,CTLC
	DB	SYSCALL,.CTLC	SET CTL-C PROCESSING
	MVI	A,377Q
	DB	SYSCALL,.CLOSE	CLOSE OVERLAY CHANNEL

*	SEE IF COMMAND LINE PASSED ON STACK

	LXI	H,0
	DAD	SP
	XCHG
	MVI	A,#STACK
	SUB	E
	MOV	C,A
	MVI	A,STACK/256
	SBB	D
	MOV	B,A		(BC) = BYTES ON STACK
	ORA	C
	STA	MODE		SET MODE <>0 IF LINE ON STACK
	JZ	START		NO LINE

*	HAVE LCOMMAND ON STACK. COPY INTO LINE BUFFER
*	(BC) = COUNT
*	(DE) = FWA

	LXI	H,LINE
	CALL	$MOVE		COPY
	MVI	M,0		ENSURE END
	JMP	START		START PROGRAM

PRS1	MVI	A,EC.NCV	NOT CORRECT VERSION
	STC
PRS2	MVI	H,NL
	DB	SYSCALL,.ERROR
	JMP	EXIT

MEML	EQU	*		MEMORY LENGTH
	STL	'RUN-TIME WORK AREAS'
	EJECT
**	THE FOLLOWING BUFFERS AND AREAS OVERLAY THE PRS CODE.
*
*	*PRS* MAY NOT USE ANY CELLS BELOW *LINE*, AT THE
*	RISK OF SMASHING ITSELF

DEFALT	EQU	PRS		DEFAULT BLOCK

MWNA	EQU	DEFALT+6	MWN WORK AREA

DESTBUF EQU	MWNA+FB.NAML	DESTINATION FILE BUFFER (ALSO USED BY *CCW*)
DESTBFE EQU	DESTBUF+256	END OF BUFFER

**	* * NOTE * *
*	DIRWORK	 USES THE SYSTEM SCRATCH AREA, LABEL. DIRWORK WILL NOT
*	BE PRESERVED DURING A SYSCALL !!

SLABEL	EQU	DESTBFE		Saved Label Sector			/2.0a/
LABEL	EQU	SLABEL+256	Label Sector				/2.0a/

*DIRWORK	EQU	SECSCR		USE SECTOR SCRATCH AREA /79.11.GC/
	SPACE	3
**	PIO.XXX - IMAGE OF SYSTEM AIO.XXX AREA
*
*	THESE CELLS MIRROR THE SYSTEM AIO.XXX AREA


PIO.DEV EQU	LABEL+256	DEVICE CODE
PIO.UNI EQU	PIO.DEV+2	UNIT NUMBER (0-9)

PIO.DIR EQU	PIO.UNI+1	DIRECTORY ENTRY

$FOPWRK	EQU	PIO.DIR+DIRELEN	WORK AREA FOR $FOPE


	ERRMI	*-MEML		FOLLOWING MUST NOT OVERLAY *PRS*
LINE	EQU	$FOPWRK+FB.NAML	COMMAND BUFFER


NAMTAB	EQU	LINE+80		NAME TABLE


BUFMINL EQU	512		MINIMUM SIZE FOR BUFFER (WHEN IN USE)
BUFF	EQU	NAMTAB		BUFFER AREA STARTS AFTER NAMTAB

RMEML	EQU	BUFF		INITIAL RUNNING MEMORY LENGTH



*	Heath assembler takes entry point on END statement	/19.07 gr/
	END	ENTRY						/19.07 gr/

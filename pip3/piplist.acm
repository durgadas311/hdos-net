	STL	'LIST - LIST DIRECTORY CONTENTS'
	EJECT
***	LIST - INDEX DIRECTORY.
*
*	DEST=SOURCE/LIST
*		   /FULL
*		   /BRIEF
*		   /MINIMUM
*		   /GROUPS
*
*	THESE SWITCHES CAUSE THE DIRECTORY CONTENTS OF THE SPECIFIED FILE(S)
*	TO BE LISTED
*
*	IN /L FORM, THE OUTPUT IS:
*
*Name	 .Ext	Size   Created	  Time	 Flags---	Date: DD-MMM-YY
*
*FILENAME.EXT  NNNNN  DD-MMM-YY  HH:MMz  SLWCABDU
*
* NNN Files, Using MMMMM Sectors (YYYYY Free)
*
*	IN /B FORM, THE OUTPUT IS:
*
*FILENAME.EXT	FILENAME.EXT	FILENAME.EXT	FILENAME.EXT	FILENAME.EXT
*
* NNN Files (YYYYY Free)
*
*	IN /M FORM, ONLY THE NAME AND EXTENSION ARE LISTED, IN ONE COLUMN.
*
*	IN /F FORM, THE OUTPUT IS:
*
*Volume: NNNNN on DD-MMM-YY  Type: System   Init Date: DD-MMM-YY  Init Ver: 3.0
*Label:  LABEL.LABEL.LABEL.LABEL.
*
*Name	 .Ext  Size Alloc   Created    Time   Flags---	Users---  Accessed  A/C
*
*FILENAME.EXT NNNNN NNNNN  DD-MMM-YY  HH:MMz  SLWCABDU	01234567  DD-MMM-YY NNN
*
* NNN Files, Using MMMMM Sectors (XXXXX Allocated, YYYYY Free, ZZZ.Z % Free)
*
*	IN /G FORM, THE OUTPUT IS:
*
*Name	 .Ext  Alloc	Decimal        Octal	  Hexidecimal	DD-MMM-YY
*		      FGN LGN LSI   FGN LGN LSI   FGN LGN LSI
*
*FILENAME.EXT  NNNNN  DDD DDD DDD   OOO OOO OOO    HH  HH  HH
*
* NNN Files, Using MMMMM Sectors (YYYYY Free)
*
*	SPECIAL CONSIDERATIONS:
*
*	A NULL NAME OR EXTENSION IS TAKEN AS '*' (WILDCARD)
*
*	IMPLIMENTATION:
*
*	A FILE LIST OF SOURCE FILES IS BUILT. THE DEVICE DIRECTORY FILE
*	IS THEN READ, AND EACH FILE IN IT IS CHECKED FOR A MATCH
*	AGAINST ANY SOURCE SPECIFICATIONS. ELIGIBLE FILES ARE LISTED.

LIST	EQU	*
FULL	EQU	*
BRIEF	EQU	*
MINIMUM EQU	*
GROUPS	EQU	*

	LDA	COMAND
	ERRNZ	I.LIS-1
	ERRNZ	I.FUL-2
	ERRNZ	I.BRE-3
	ERRNZ	I.MIN-4
	ERRNZ	I.GRP-5
	DCR	A

LIST1	STA	LSTA		(LSTA) 0=/L 1=/F 2=/B 3=/M 4=/G
	LXI	H,0
	SHLD	LSTC		CLEAR SECTORS USED COUNT
	SHLD	LSTCA		CLEAR ALL. SECTORS COUNT
	XRA	A
	STA	LSTB		LSTB = FILE COUNT = 0
	STA	PFID		ZERO # FILES ACROSS
	CALL	$MOVEL
	DW	9,S.DATE,LSTD1	SET DATE IN /F HEADING
	CALL	$MOVEL
	DW	9,S.DATE,LSTG5. SET DATE IN /L HEADING
	CALL	$MOVEL
	DW	9,S.DATE,LSTG4. SET DATE IN /G HEADING

*	CRACK DESTINATION FILE NAMES

	CALL	DDF		DECODE DEST FILE NAME
	JC	ERROR		FILE NAME ERROR
	ANA	A
	MVI	A,PEC.IUW	ILLEGAL USE OF WILDCARD IN DEST
	JZ	ERROR

*	BUILD LIST OF SPECIFICATIONS

	CALL	BLS		BUILD LIST OF SOURCE SPECS
	JC	ERROR		ERROR IN LIST
	LXI	B,3
	LXI	H,DIRNAM
	CALL	$MOVE		MOVE DEVICE CODE INTO DIRECT.SYS NAME
	LXI	H,DIRNAM+2
	MOV	A,M		SEE IF UNIT NUMBER OMITTED
	ANA	A
	JNZ	LIST1.5		SPECIFIED
	MVI	M,'0'		DONT ALLOW NULL NUMBER

*	GET ADDRESS OF DEVICE'S GRT

LIST1.5	LXI	H,DIRNAM	(HL) = # OF XXX:DIRECT.SYS (XXX = DEVICE)
	LXI	B,LSTD		(BC) = ADDRESS FOR RETURN INFO
	SCALL	.DECODE		DECODE NAME
	JC	ERROR		UNKNOWN DEVICE
	LDA	LSTD+0
	ANI	DT.DD
	MVI	A,EC.DNS
	JZ	ERROR		NOT DIRECTORY DEVICE
	LHLD	LSTD+17 	(HL) = DEV TBL ADDR

	LXI	D,DEV.UNT
	DAD	D
	LDA	LSTD+3
	CALL	S.GUP		HL = UNIT TABLE POINTER

	ERRNZ	UNT.FLG
	MOV	A,M
	ANI	DT.P3
	STA	LSTP3		SAVE PRE-3.0 MEDIA FLAG

	CALL	$INDLB
	DW	UNT.SPG
	STA	LSTF		SAVE SECTORS PER GROUP

	CALL	$INDL
	DW	UNT.GRT
	XCHG
	SHLD	LSTE		SAVE GRT ADDRESS
*	XCHG			WHY IS THIS HERE ?

	LDA	LSTA
	DCR	A
	JNZ	LIST1.6 	NOT /F

*	READ VOL LABEL SECTOR

	LHLD	DIRNAM		(HL) = DEVICE
	LDA	DIRNAM+2	(A)  = UNIT
	SUI	'0'		MAKE BINARY
	LXI	D,LABEL 	BUFFER
	CALL	RVL		READ VOL LABEL
	JC	ERROR

	LDA	LABEL+LAB.VER		; version number of INIT
	CPI	3*16+0			; before 3.0?
	LDA	LABEL+LAB.SER		; get short volume number
	MOV	C,A
	MVI	B,0
	JC	LIST15. 		; early version disk

	LHLD	LABEL+LAB.LVN		; long number
	MOV	B,H
	MOV	C,L

LIST15. MVI	A,5
	LXI	H,LSTV0
	CALL	$UDDN

	LDA	LABEL+LAB.VER		; version number of INIT
	CPI	2*16+0			; before 2.0?
	LXI	H,400
	JC	LIST16

	LHLD	LABEL+LAB.SIZ	VOL SIZE
LIST16	SHLD	LSTCB

	LXI	D,LSTD2 	INIT DATE
	LHLD	LABEL+LAB.IND
	XCHG
	CALL	$DAD		DECODE DATE

	LXI	H,LSTV1 	VOL TYPE
	LXI	B,6
	LDA	LABEL+LAB.VLT
	LXI	D,VT.D
	ANA	A
	JZ	LIST1.V
	LXI	D,VT.S
	DCR	A
	JZ	LIST1.V
	LXI	D,VT.U
LIST1.V CALL	$MOVE

	LXI	D,LABEL+LAB.VER INIT VER
	LXI	H,LSTV2
	CALL	PFI50		DECODE BCD VALUE
	MOV	M,A
	DCX	H
	MVI	M,'.'

*	OPEN DEVICE'S DIRECTORY

LIST1.6 LXI	H,DIRNAM
	MVI	A,CN.DIR
	SCALL	.OPENR
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JC	ERROR		CAN'T OPEN DIRECTORY

*	OPEN OUTPUT FILE

	LXI	H,DESTFB
	CALL	$FOPEW		OPEN FOR WRITE

*	GENERATE HEADING

	LDA	LSTA
	DCR	A
	JNZ	LIST1.7 	NOT /F

	LXI	B,LSTVL 	PRINT VOL DATA
	LXI	D,LSTV
	CALL	$FWRIB
	LXI	B,LSTLL
	LXI	D,LSTL
	CALL	$FWRIB
	PUSH	H
	LXI	H,LABEL+LAB.LAB
	PUSH	H
	CALL	$DTB
	MOV	C,A		LENGTH OF LABEL & 00
	MVI	B,0
	DAD	B		(BC) = LENGTH
	DCX	H
	MVI	M,NL
	POP	D		(DE) = TEXT
	POP	H		(HL) = DESTFB
	CALL	$FWRIB

LIST1.7 CALL	LISTHD		DISPLAY HEADING

	LDA	LSTA
	DCR	A
	LDA	PAGE		LINE COUNT PER PAGE
	JNZ	LIST1.8 	NOT FULL DISPLAY

	SUI	3		ACCOUNT FOR ADDITIONAL INFO ON 1ST PAGE
LIST1.8 STA	LINCNT		SET LINE COUNTER

*	READ DIRECTORY BLOCKS, LOOKING FOR FILE MATCHES

	CALL	EBM		EXPAND BUFFER
	LHLD	BUFPTR
	SHLD	BPOINT
LIST3	LXI	B,512
	CALL	GDWP		DE = DIRECTORY WORKSPACE POINTER
	MVI	A,CN.DIR
	PUSH	D
	SCALL	.READ
	POP	D		DE = DIRECTORY WORKSPACE
	JC	LIST9		ALL DONE

*	CHECK NEXT ENTRY IN NAMTAB AGAINST DIRECTORY ENTRY.
*	(DE) = DIRECTORY BUFFER POINTER

LIST4	LDAX	D		(A) = FIRST CHARACTER OF NAME
	ANA	A
	JZ	LIST3		END OF THIS BUFFER
	INR	A
	ERRNZ	DF.EMP-377Q
	JZ	LIST7		THIS ENTRY IS EMPTY
	INR	A
	JZ	LIST9		NO MORE ENTRYS IN DIRECTORY
	XCHG
	CALL	CFE		CHECK FILE ELIGIBILITY
	XCHG
	JNE	LIST7		NOT ELIGIBLE
	LXI	H,NAMTAB

LIST5	PUSH	H
	PUSH	D		SAVE ADDRESS OF FILE AND PATTERN
	CALL	CAD		CONVERT ASCII NAMTAB ENTRY TO DIRECTORY FORMAT
	LXI	D,PIO.DIR+DIR.NAM	(DE) = NAMTAB PATTERN
	POP	H
	PUSH	H		(HL) = DIRECTORY PATTERN
	MVI	B,8+3		CHECK FOR MATCH
	CALL	CWM		CHECK FOR WILDCARD MATCH
LIST6	POP	D
	POP	H

*	KLUDGE METHOD FOR NEGATE STATE

	PUSH	PSW
	LDA	NEGATE
	XTHL
	XRA	L
	MOV	L,A
	XTHL
	POP	PSW

	JZ	LIST8		GOT FILE TO LIST
	LXI	B,FB.NAML
	DAD	B		ADVANCE PAST ENTRY IN NAMTAB

*	SEE IF AT END OF NAMTAB

	PUSH	D
	XCHG			(DE) = NEW ADDRESS
	LHLD	NAMTLEN
	LXI	B,NAMTAB
	DAD	B		(HL) = LWA+1 OF TABLE
	XCHG
	CALL	$CDEHL		COMPARE
	POP	D
	JNE	LIST5		MORE IN TABLE

*	FILE DOESN'T MATCH ANY SELECTED FILE. PASS TO NEXT ONE

LIST7	XCHG			(HL) = DIR BUFFER ADDRESS

	PUSH	H
	CALL	GDWP.		HL = DIRECTORY WORKSPACE PTR.
	CALL	$INDLB		A  = DIR. ENTRY LENGTH
	DW	DIS.ENL
	POP	H

	CALL	$DADA.		ADVANCE
	MOV	A,M
	ANA	A
	XCHG
	JNZ	LIST4		TRY THIS ONE
	JMP	LIST3		READ ANOTHER BLOCK

*	HAVE FILE TO LIST

LIST8	PUSH	D		SAVE DIR POINTER

	LHLD	BPOINT		SAVE ENTRY IN BUFFER
	LXI	B,DIRELEN
	CALL	$MOVE
	SHLD	BPOINT		ADVANCE POINTER

*	CONTINUE WITH LISTING

	POP	D
	LXI	H,LSTB
	INR	M		COUNT FILE
	JMP	LIST7		ADVANCE TO NEXT FILE

*	ALL DONE. CLOSE DIRECTORY FILE

LIST9	MVI	A,CN.DIR
	SCALL	.CLOSE		CLOSE FILE

	LDA	LSTB
	ANA	A
	JZ	LIST10		NO FILES TO LIST

	LDA	SORT		SHALL WE SORT?
	ANA	A
	JZ	LIST9.0

*	SORT BUFFER

	LHLD	BUFPTR
	SHLD	LSTTAB
	LDA	LSTB
	MOV	L,A
	MVI	H,0
	SHLD	LSTCNT

	LDA	REVERSE 	(A)=0 IF ASCEND. (A)=3 IF DESCEND.
	LXI	H,$SORT
	CALL	$DADA
	SHLD	SRTCAL

	CALL	$SORT
SRTCAL	EQU	*-2
LSTTAB	DW	*-*
	DW	DIRELEN
LSTCNT	DW	*-*
	DW	FIELDS
	DW	SORTAB

*	LOOP *LSTB* TIMES PRINTING ENTRYS

LIST9.0 LHLD	BUFPTR		START OF BUFFER
	LDA	LSTB		COUNT
LIST9.1 PUSH	PSW
	PUSH	H
	XCHG			DE = ENTRY POINTER

	CALL	PFI		PRINT FILE INFO

*	CHECK FOR PAGINATION

	LDA	PAGE
	ANA	A
	JZ	LIST9.2

	LXI	H,LINCNT	POINT TO LINE COUNTER
	DCR	M
	JNZ	LIST9.2 	NOT TIME

*	SPIT OUT A NEW PAGE

	LXI	H,DESTFB
	LXI	D,LSTFF 	FORM FEED
	LXI	B,LSTFFL
	CALL	$FWRIB

	CALL	LISTHD		FOLLOWED BY NEW HEADING

	LDA	PAGE
	STA	LINCNT		RESET LINE COUNTER

LIST9.2 POP	H
	LXI	B,DIRELEN
	DAD	B		ADVANCE POINTER
	POP	PSW
	DCR	A
	JNZ	LIST9.1

LIST10	LDA	LSTA		LISTING TYPE
	CPI	3		/M
	JZ	LISTM		NO SUMMARY

*	FILL IN SUMMARY DATA

	LDA	LSTB
	MOV	C,A
	MVI	B,0		(BC) = FILE COUNT
	MVI	A,3
	LXI	H,LSTH1
	CALL	$UDDS		FILE COUNT

	LHLD	LSTC		SECTORS USED
	MOV	B,H
	MOV	C,L		(BC) = SECTOR COUNT
	LXI	H,LSTH2
	MVI	A,5
	CALL	$UDDN		USED COUNT

	LHLD	LSTCA
	MOV	B,H
	MOV	C,L
	LXI	H,LSTH4
	MVI	A,5
	CALL	$UDDN		ALLOCATED COUNT

	LHLD	LSTE
	MOV	A,M
	CALL	CFS		FOLLOW GRT CHAIN
	XCHG
	SHLD	LSTCA		SAVE CLUSTERS FREE FOR % CALC
	XCHG
	LDA	LSTF
	CALL	$MU86		(HL) = SECTORS FREE
	MOV	B,H
	MOV	C,L
	LXI	H,LSTH5
	MVI	A,5
	CALL	$UDDN		UNPACK FREE

	LHLD	LSTCB		(HL) = DISK SIZE
	MOV	B,H
	MOV	C,L		(BC) = SIZE IN SECTORS
	LDA	LSTF
	MOV	E,A
	MVI	D,0		(DE) = SECTORS PER CLUSTER
	CALL	$DU66		(HL) = SIZE IN CLUSTERS
	PUSH	H		SAVE SIZE IN CLUSTERS
	LHLD	LSTCA		(HL) = CLUSTERS FREE
	XCHG
	CALL	$MU10		(HL) = CLUSTERS FREE * 10
	XCHG
	CALL	$MU10		(HL) = CLUSTERS FREE * 100
	MOV	B,H
	MOV	C,L		(BC) = CLUSTERS FREE * 100
	POP	D
	PUSH	D		(DE) = SIZE IN CLUSTERS
	CALL	$DU66		(HL) = WHOLE % FREE
	PUSH	D		REMAINDER
	MOV	B,H
	MOV	C,L		(BC) = % FREE
	LXI	H,LSTH7
	MVI	A,3
	CALL	$UDDN		UNPACK %
	POP	D		REM
	CALL	$MU10		(HL) = REM * 10
	POP	D
	PUSH	D		(DE) = SIZE IN CLUSTERS
	MOV	A,E
	ANI	376Q
	RRC			(A) = (A)/2
	MOV	E,A
	DAD	D		ROUND TO NEAREST 1/10
	MOV	B,H
	MOV	C,L		(BC) = REM * 10 , ROUNDED
	POP	D		(DE) = SIZE IN CLUSTERS
	CALL	$DU66		(HL) = DECIMAL % FREE
	MOV	B,H
	MOV	C,L
	LXI	H,LSTH7+4
	MVI	A,1
	CALL	$UDDN		UNPACK .X%

	LDA	SUPRES
LISTM	ANA	A
	LXI	H,DESTFB
	JNZ	$FCLO		NO SUMMARY,CLOSE & EXIT

	LDA	LSTA		LISTING TYPE
	CPI	2		/B
	JE	LISTB		BRIEF SUMMARY
	DCR	A		/F
	JZ	LISTF		FULL SUMMARY

LISTL	LXI	B,LSTHL 	STANDARD SUMMARY
	LXI	D,LSTH		Files & Using & (
	CALL	$FWRIB
	JMP	LISTB.

LISTB	LXI	B,LSTH1L
	LXI	D,LSTH		Files
	CALL	$FWRIB
	LXI	B,2
	LXI	D,LSTH3 	' ('
	CALL	$FWRIB
LISTB.	LXI	B,LSTH5L
	LXI	D,LSTH5 	Free
	CALL	$FWRIB
	LXI	B,2
	LXI	D,LSTH8 	')',NL
	JMP	LISTF.

LISTF	LXI	B,LSTHFL	(BC) = COUNT
	LXI	D,LSTH		(DE) = TEXT
LISTF.	CALL	$FWRIB		WRITE TRAILER

*	ALL DONE. CLOSE OUTPUT FILE

	JMP	$FCLO		CLOSE AND EXIT

*	DISPLAY THE HEADING LINE

LISTHD	LDA	SUPRES
	CPI	2
	RNC			NO HEADING WANTED

	LDA	LSTA		LISTING TYPE
	CPI	3		/M
	RZ			NO HEADING
	LXI	B,1		(BC) = TEXT COUNT
	LXI	D,LSTG		(DE) = TEXT ADDRESS
	CPI	2		/B
	JZ	LISTHD2 	ONLY <NL> AS HEADING
	MVI	C,LSTGFL	(BC) = TEXT COUNT
	CPI	1		/F
	JZ	LISTHD2 	FULL HEADING
	CPI	4		/G
	JZ	LISTHG

	MVI	C,LSTGL 	STANDARD HEADING
	CALL	$FWRIB
	MVI	C,LSTG3L
	LXI	D,LSTG3
	CALL	$FWRIB
	MVI	C,LSTG5L
	LXI	D,LSTG5

LISTHD2	JMP	$FWRIB		WRITE HEADING AND EXIT

LISTHG	MVI	C,LSTGL 	GROUP HEADING
	CALL	$FWRIB
	MVI	C,LSTG4L
	LXI	D,LSTG4
	JMP	$FWRIB

	SPACE	4,10
*	DATA AREAS FOR LIST

LSTA	DB	0		0=/L 1=/F 2=/B 3=/M 4=/G
LSTB	DB	0		FILE COUNT
LSTC	DW	0		SECTORS USED
LSTCA	DW	0		ALL. SECTORS/SECTORS FREE
LSTCB	DW	0		DISK SIZE IN SECTORS
LSTD	DS	24		FILE NAME DECODE AREA
LSTE	DW	0		GRT ADDRESS
LSTF	DB	0		SECTORS PER GROUP FOR THIS DEVICE
LSTP3	DB	0		FLAG FOR PRE-3.0 MEDIA
LINCNT	DB	0		LINE COUNTER FOR PAGINATION

BPOINT	DW	0		BUFFER POINTER FOR LIST

FIELDS	DB	0,8		FILE NAME (CHARS)
	DB	8,3		EXTENSION (CHARS)
	DB	19,0		CREATION DATE (WORD)
	DB	21,0		ACCESSED DATE (WORD)
	DB	13,1		ACCESS COUNT (BYTE)

LSTV	DB	'Volume: '	VOLUME DATA LINE
LSTV0	DB	'NNNNN on '
LSTD1	DB	'DD-MMM-YY',32,32,32,'Type: '
LSTV1	DB	'......',32,32,'Init Date: '
LSTD2	DB	'DD-MMM-YY',32,32,32,'Init Ver: '
LSTV2	DB	'V.V',NL
LSTVL	EQU	*-LSTV

VT.D	DB	'Data',32,32
VT.S	DB	'System'
VT.U	DB	'??????'

LSTL	DB	'Label:',TAB	VOLUME LABEL LINE
LSTLL	EQU	*-LSTL

LSTFF	DB	FF		FORM FEED
LSTFFL	EQU	*-LSTFF

LSTG	DB	NL,'Name',TAB,'.Ext',32 	   HEADER LINE
LSTGL.	EQU	*-LSTG
	DB	32,'Size'
LSTGL	EQU	*-LSTG
LSTG2	DB	32,'Alloc'
LSTG2L	EQU	*-LSTG2
LSTG3	DB	32,32,32,'Created',32,32,32,32,'Time',32,32,32,'Flags---'
LSTG3L	EQU	*-LSTG3
	IF	USER
	DB	32,32,'Users---'
	ENDIF
	DB	32,32,'Accessed',32,32,32,'A/C',NL,NL
LSTGFL	EQU	*-LSTG
LSTG4	DB	32,32,32,32,'Decimal',32,32,32,32,32,32,32,32
	DB	'Octal',32,32,32,32,32,32,'Hexadecimal',32,32,32
LSTG4.	DB	'DD-MMM-YY',NL,TAB,TAB,32,32,32,32
	DB	'FGN',32,'LGN',32,'LSI',32,32,32
	DB	'FGN',32,'LGN',32,'LSI',32,32,32
	DB	'FGN',32,'LGN',32,'LSI',NL,NL
LSTG4L	EQU	*-LSTG4
LSTG5	DB	TAB,TAB,'Date:',32
LSTG5.	DB	'DD-MMM-YY',NL,NL
LSTG5L	EQU	*-LSTG5

LSTH	DB	NL		SUMMARY LINE
LSTH1	DB	'NNN Files'
LSTH1L	EQU	*-LSTH
	DB	', Using '
LSTH2	DB	'MMMMM Sectors'
LSTH3	DB	' ('
LSTHL	EQU	*-LSTH
LSTH4	DB	'XXXXX Allocated, '
LSTH5	DB	'YYYYY Free'
LSTH5L	EQU	*-LSTH5
LSTH6	DB	', '
LSTH7	DB	'ZZZ.Z % Free'
LSTH8	DB	')',NL
LSTHFL	EQU	*-LSTH
	SPACE	4,10
**	BLS - BUILD LIST OF SOURCE FILES.
*
*	BLS BUILDS A LIST OF SOURCE FILES INTO *NAMTAB*
*	NULL FIELDS ARE SET TO WILDCARDS. BLS REQUIRES THAT ALL
*	FILES SPECIFIED HAVE THE SAME DEVICE.
*
*	IF THE COMMAND LINE CONTAINS NO FILES, BUT CONTAINS AT LEAST
*	ONE BLANK (AS WOULD BE THE CASE IN PROCESSING THE /LIST SWITCH, SINCE
*	THE '/LIST' IS REPLACED WITH BLANKS) A FILE NAME OF ????????.???
*	IS DECODED.
*	ENTRY	NAMTAB EMPTY
*	EXIT	'C' CLEAR IF OK
*		(DE) = #BLSA = 3 CHARACTER DEVICE NAME
*		'C' SET IF ERROR
*		 (A) = ERROR MESSAGE
*	USES	ALL

BLS	CALL	$MOVEL
	DW	3,BLSC,BLSA	SET INITIAL DEFAULT DEVICE
	LXI	H,0
	SHLD	NAMTLEN		CLEAR NAMTAB
	MVI	A,377Q
	STA	BLSB		FLAG PROCESSING OF FIRST FILE NAME
	CALL	LSN		LOCATE SOURCE NAMES

*	CRACK THE NEXT NAME

BLS1	MOV	A,M
	LXI	D,BLSA		(DE) = DEFAULT ADDRESS
	ANA	A
	RZ			NO MORE NAMES
	CALL	$SOB		SEE IF ALL NULL
	ANA	A
	JNZ	BLS2		NOT ALL NULL
	LXI	H,BLSC		USE DEFAULT DEVICE
BLS2	CALL	CAD.		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR

*	IF FIRST NAME, RECORD DEVICE
*	IF NOT FIRST, COMPARE DEVICE AGAINST FIRST DEVICE

	PUSH	H
	LXI	D,PIO.DEV
	LXI	H,BLSA
	LXI	B,3		SETUP COUNT, FROM AND TO
	LDA	BLSB
	ANA	A
	JP	BLS3		NOT 1ST FILE
	CALL	$MOVE		MOVE IN REQUIRED DEVICE FOR REMAINING FILES
	XRA	A
	STA	BLSB		FLAG 1ST NAME PROCESSED
	JMP	BLS4

BLS3	CALL	$COMP		SEE IF THIS DEVICE SAME AS PREVIOUS
	JE	BLS4		OK
	MVI	A,PEC.DNC	MULTIPLE DEVICES ARE ILLEGAL
	STC
	POP	H
	RET			RETURN WITH ERROR

*	GOT NAME DECODED. ENTER IN NAMTAB

BLS4	CALL	AEN		ADD ENTRY TO NAMTAB
	POP	H
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BLS1		SEE IF MORE

BLSA	DB	'SY0',200Q,200Q,200Q
BLSB	DB	0		FIRST FILE NAME FLAG
BLSC	DB	'SY0:',0		DEFAULT DEVICE
	SPACE	4,10
**	PFI - PRINT FILE INFO.
*
*	PFI DECODES A DIRECTORY ENTRY INTO A CODED LINE, THEN
*	WRITES IT TO 'DESTFB'.
*
*	THE PRODUCED FORMAT DEPENDS UPON THE LISTING FORMAT FLAG,
*	LSTA.
*
*	LONG FORM:
*
*	NAME	.EXT   SIZE    DATE	TIME   FLAGS (NL)
*
*	SHORT FORM:
*
*	NAME	.EXT	(TAB)
*
*	MINIMUM FORM:
*
*	NAME.EXT (NL)
*
*	FULL FORM:
*
*	NAME  .EXT  SIZE  ALLOC  CREATED  TIME	FLAGS  USER  ACCESSED  A/C (NL)
*
*	GROUP FORM:
*
*	NAME  .EXT  SIZE  FGN LGN LSI  FGN LGN LSI  FGN LGN LSI (NL)
*
*	ENTRY	(DE) = DIRECTORY ENTRY POINTER
*	EXIT	IF LONG FORM, SECTOR COUNT IS ACCUMULATED IN LSTC
*	USES	ALL

PFI	LXI	H,PFIA
	MVI	C,8
	CALL	PFI20		COPY NAME
	JZ	PFI1		ALL 8 CHAR
	LDA	LSTA
	CPI	3
	JZ	PFI1		SKIP TAB IN /M FORM
	MVI	M,TAB
	INX	H
PFI1	MVI	M,'.'
	INX	H
	MVI	C,3
	CALL	PFI20		COPY EXT
	LDA	LSTA
	CPI	3		/M
	JZ	PFI1.5
	CPI	2		/B
	JZ	PFI1.4
	INR	C		+ 1 SPACES
PFI1.1	MVI	M,' '
	INX	H
	DCR	C
	JNZ	PFI1.1
	JMP	PFI3

*	IS SHORT FORM. SEE IF NEED TO END LINE

PFI1.4	MVI	M,TAB
	INX	H
	PUSH	H
	LXI	H,COLUMN
	MOV	A,M
	ANA	A
	JNZ	PFI.14
	MVI	M,5		DEFAULT
PFI.14	LDA	PFID
	INR	A
	CMP	M
	POP	H
	JNE	PFI2		NOT TIME YET
	DCX	H
PFI1.5	MVI	M,NL
	INX	H		TIME TO END LINE
	XRA	A
PFI2	STA	PFID		RESET COUNT
	JMP	PFI6		OUTPUT TO FILE

*	IS LONG OR FULL FORM.

PFI3	EQU	*

	XCHG			(DE) = LINE ADDR (HL) = POINTER
	SHLD	PFIDIR

*	DECODE FILE SIZE

	LXI	B,DIR.FGN-DIR.EXT-3
	DAD	B		(HL) = #DIR.FGN
	MOV	A,M		(A) = DIR.FGN
	INX	H
	INX	H
	MOV	C,M		(C) = DIR.LSI = SECTORS USED IN LAST GROUP
	ERRNZ	DIR.LSI-DIR.FGN-2
	XCHG			(DE) = ADDRESS OF LSI
	PUSH	D		SAVE #DIR.LSI
	PUSH	H		SAVE LINE ADDRESS
	LHLD	LSTE
	MOV	L,A
	MOV	A,M
	CALL	CFS		COMPUTE FILE SIZE
	LDA	LSTF		(A) = SECTORS PER GROUP

	MOV	B,A
	CALL	$MU86	(HL) = SECTORS USED (EXCEPT FOR THOSE IN LAST GROUP)
	SHLD	PFIS		SAVE PARTIAL SIZE
	LDA	ALLOCA
	ANA	A
	JZ	PFI3.5
	MOV	C,B		Use Group Size instead if /ALL

PFI3.5	EQU	*

	MVI	B,0
	DAD	B		(HL) = SECTORS USED
	MOV	B,H
	MOV	C,L		(BC) = SECTORS USED COUNT
	LHLD	LSTC
	DAD	B
	SHLD	LSTC		ACCUMULATE COUNT OF SECTORS
	POP	H		(HL) = LINE ADDRESS
	MVI	A,5		5 DIGITS MAX
	CALL	$UDDS		UNPACK COUNT

	LDA	LSTA
	CPI	4		/G
	JE	PFIG
	DCR	A
	JNZ	PFI4		NOT /F

*	DECODE FILE ALLOCATION

	MVI	M,' '
	INX	H
	PUSH	H
	LHLD	PFIS		PARTIAL SIZE
	LDA	LSTF
	MOV	C,A
	MVI	B,0
	DAD	B
	MOV	B,H
	MOV	C,L		ALLOCATED SECTORS
	LHLD	LSTCA
	DAD	B
	SHLD	LSTCA		ACCUMULATE
	POP	H
	MVI	A,5
	CALL	$UDDS		UNPACK ALLOC SECTORS

*	TYPE CREATION DATE

PFI4	POP	D		(DE) = #DIR.LSI
	CALL	PFI40		INSERT 2 SPACES
	XCHG
	ERRNZ	DIR.CRD-DIR.LSI-1
	INX	H		(HL) = #DIR.CRD
	PUSH	H
	CALL	$HLIHL
	XCHG
	CALL	$DAD		DECODE AUGUSTAN DATE

*	DECODE TIME

	CALL	PFI40		INSERT 2 SPACES

	LDA	LSTP3		If media is pre-3.0
	ANA	A		  then don't show time
	JNZ	PFI.NT

	XCHG
	POP	H		(HL) = #DIR.CRD
	PUSH	H
	LXI	B,DIR.CTH-DIR.CRD
	DAD	B
	XCHG			(DE) => HOURS BYTE IN BCD, (HL) = LINE

	LDAX	D		If hours set to 377Q
	CPI	377Q		  then don't show time
	JE	PFI.NT

	CALL	PFI50		DECODE BCD
	PUSH	D		HOURS
	PUSH	H		LINE
	DCX	H
	DCX	H
	PUSH	H		LINE-2

	LXI	H,T.AP		SET AM OR PM
	LDAX	D
	STA	PFIT
	CPI	12H
	JNC	T.PM
T.AM	MVI	M,'a'
	JMP	T.0

T.PM	MVI	M,'p'
	SUI	12H
	DAA
	STA	PFIT
	LXI	D,PFIT
	POP	H		LINE-2
	PUSH	H		LINE-2
	CALL	PFI50		DECODE ADJUSTED HOURS

T.0	LDA	PFIT		IF HOUR = '00' THEN MAKE IT '12'
	POP	H		LINE-2
	ANA	A
	JNZ	T.1
	MVI	M,'1'
	INX	H
	MVI	M,'2'
	DCX	H
T.1	MVI	A,'0'		IF FIRST CHAR IS '0' REPLACE WITH ' '
	CMP	M
	JNE	T.2
	MVI	M,' '
T.2	POP	H		LINE
	POP	D		HOURS
	MVI	M,':'
	INX	H
	INX	D
	ERRNZ	DIR.CTM-DIR.CTH-1
	CALL	PFI50		DECODE BCD
	MVI	M,'z'		SET AM OR PM
T.AP	EQU	*-1
	INX	H
	JMP	PFI.F

PFI.NT	CALL	PFI40		INSERT 2 SPACES
	CALL	PFI40		INSERT 2 SPACES
	CALL	PFI40		INSERT 2 SPACES

*	DECODE FLAGS

PFI.F	CALL	PFI40		INSERT 2 SPACES
	XCHG			(DE) = LINE ADDRESS
	POP	H		(HL) = #DIR.CRD
	PUSH	H
	LXI	B,DIR.FLG-DIR.CRD
	DAD	B		(HL) = ADDRESS OF DIRFLG
	MOV	A,M		(A) = FLAGS
	XCHG			(HL) = LINE ADDR
	LXI	D,PFIB
	CALL	PFI30		DECODE FLAG BYTE
	XCHG			(DE) = LINE ADDR
	POP	H		(HL) = #DIR.CRD
	XCHG			(HL) = LINE ADDR

	LDA	LSTA		LISTING TYPE
	DCR	A
	JNZ	PFI5		NOT /F

*	DECODE USER AREAS

	IF	USER
	CALL	PFI40		INSERT 2 SPACES
	XCHG			(DE) = LINE ADDR
	LHLD	PFIDIR
	LXI	B,DIR.USR-DIR.EXT-3
	DAD	B
	MOV	A,M		(A) = USER AREAS
	ORI	200Q		FORCE USER AREA 0
	XCHG			(HL) = LINE ADDR
	PUSH	D
	LXI	D,PFIU
	CALL	PFI30		DECODE FLAG BYTE
	POP	D
	ENDIF

*	TYPE LAST ACCESS DATE

	CALL	PFI40		INSERT 2 SPACES
	IF	USER
	XCHG			(HL) = #DIR.USR
	LXI	B,DIR.ACD-DIR.USR
	ELSE
	XCHG			(HL) = #DIR.CRD
	LXI	B,DIR.ACD-DIR.CRD
	ENDIF
	DAD	B		(HL) = #DIR.ACD
	PUSH	H
	CALL	$HLIHL
	XCHG			(HL) = LINE ADDR
	CALL	$DAD		DECODE AUGUSTAN DATE
	CALL	PFI40		INSERT 2 SPACES

*	TYPE NUMBER OF ACCESSES

	XCHG			(DE) = LINE ADDR
	POP	H
	LXI	B,DIR.NOA-DIR.ACD
	DAD	B		(HL) = #DIR.NOA
	MOV	A,M		(A) = # OF ACCESSES
	ANA	A
	XCHG			(HL) = LINE ADDR
	JNZ	PFI4.1

PFI4.0	LXI	D,-12		BACK UP OVER DATE
	DAD	D
	JMP	PFI5		IF A/C=0 THEN SHOW NO DATE OR COUNT

PFI4.1	MOV	C,A		(C) = NUMBER OF ACCESSES
	MVI	B,0

	LDA	LSTP3		If media is pre-3.0
	ANA	A		  then don't show acc. date
	JNZ	PFI4.0		    or acc. count

	MVI	A,3
	CALL	$UDDS
	JMP	PFI5

PFIG	CALL	PFI40		INSERT 2 SPACES
	POP	D		DE = #DIR.LSI
	ERRNZ	DIR.LSI-DIR.FGN-2
	DCX	D		DE = #DIR.LGN
	DCX	D		DE = #DIR.FGN
	PUSH	D		SAVE PTR
	LDAX	D
	MOV	C,A
	MVI	B,0
	MVI	A,3
	CALL	$UDD		UNPACK FGN
	MVI	M,' '
	INX	H
	POP	D
	INX	D
	PUSH	D
	LDAX	D
	MOV	C,A
	MVI	B,0
	MVI	A,3
	CALL	$UDD		UNPACK LGN
	MVI	M,' '
	INX	H
	POP	D
	INX	D
	PUSH	D
	LDAX	D
	MOV	C,A
	MVI	B,0
	MVI	A,3
	CALL	$UDD		UNPACK LSI
	MVI	M,' '
	INX	H
	CALL	PFI40		INSERT 2 SPACES
	POP	D		DE = #DIR.LSI
	DCX	D		DE = #DIR.LGN
	DCX	D		DE = #DIR.FGN
	PUSH	D		SAVE PTR
	LDAX	D
	CALL	$UOB		UNPACK FGN
	MVI	M,' '
	INX	H
	POP	D
	INX	D
	PUSH	D
	LDAX	D
	CALL	$UOB		UNPACK LGN
	MVI	M,' '
	INX	H
	POP	D
	INX	D
	PUSH	D
	LDAX	D
	CALL	$UOB		UNPACK LSI
	CALL	PFI40		INSERT 2 SPACES
	CALL	PFI40		INSERT 2 SPACES
	POP	D		DE = #DIR.LSI
	DCX	D		DE = #DIR.LGN
	DCX	D		DE = #DIR.FGN
	PUSH	D		SAVE PTR
	LDAX	D
	CALL	$UHB		UNPACK FGN
	CALL	PFI40		INSERT 2 SPACES
	POP	D
	INX	D
	PUSH	D
	LDAX	D
	CALL	$UHB		UNPACK LGN
	CALL	PFI40		INSERT 2 SPACES
	POP	D
	INX	D
	LDAX	D
	CALL	$UHB		UNPACK LSI

PFI5	MVI	M,NL
	INX	H

*	LINE ALL BUILT. WRITE TO DESTFB

PFI6	LXI	D,-PFIA
	DAD	D
	MOV	B,H
	MOV	C,L		(BC) = LEN
	LXI	D,PFIA		(DE) = DATA FWA
	LXI	H,DESTFB
	JMP	$FWRIB		WRITE AND EXIT
	SPACE	3,10
**	PFI20 - COPY FILE NAME.
*
*	PFI20 COPIES A NAME FIELD FROM THE DIRECTORY ENTRY TO A CODED
*	LINE
*
*	ENTRY	(DE) = DIRECTORY ADDRESS
*		(C) = NAME LENGTH
*		(HL) = LINE ADDRESS
*	EXIT	(DE) = (DE) + (C)
*		'Z' SET IF MAX CHARACTERS COPIED
*	USES	A,F,C,D,E,H,L

PFI19	MOV	M,A		COPY
	INX	H
	INX	D
	DCR	C
	RZ			ALL COPIED
PFI20	LDAX	D
	ANA	A
	JNZ	PFI19		GOT CHAR

*	NO NAME. (C) = COUNT LEFT

	MOV	A,E
	ADD	C
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	ORA	E		CLEAR 'Z'
	RET
	SPACE	3,10
**	PFI30 - DECODE FLAGS
*
*	PFI30 DECODES A FLAG BYTE FROM THE DIRECTORY ENTRY TO A CODED
*	LINE
*
*	ENTRY	(DE) = FLAG CODES
*		(HL) = LINE ADDRESS
*		(A)  = FLAG BYTE
*	EXIT	(HL) = (HL) + 8
*		(DE) = (DE) + 8
*		(A)  = 0
*	USES	A,F,C,D,E,H,L

PFI30	MVI	C,8		8 BITS IN A FLAG BYTE
PFI31	ADD	A		SHIFT BIT 7 TO CARRY
	PUSH	PSW
	LDAX	D		FLAG CHAR
	JC	PFI32		IF BIT IS SET
	MVI	A,' '		IF BIT IS OFF
PFI32	MOV	M,A		PUT IN LINE
	INX	H		BUMP POINTERS
	INX	D
	POP	PSW
	DCR	C		COUNT DOWN
	JNZ	PFI31		LOOP
	RET
	SPACE	3,10
**	PFI40 - PUT TWO SPACES IN CODED LINE
*
*	ENTRY	(HL) = LINE ADDR
*	EXIT	(HL) UPDATED

PFI40	MVI	M,' '
	INX	H
	MVI	M,' '
	INX	H
	RET
	SPACE	3,10
**	PFI50 - DECODE BCD BYTE INTO CODED LINE
*
*	ENTRY	(DE) = BCD BYTE ADDR
*		(HL) = LINE ADDR
*	EXIT	(HL) = (HL) + 2
*
*	USES	A,F,H,L

PFI50	LDAX	D		(A) = BCD BYTE
	ANI	0F0H
	RRC
	RRC
	RRC
	RRC
	ADI	'0'
	MOV	M,A
	INX	H
	LDAX	D		(A) = BCD BYTE
	ANI	0FH
	ADI	'0'
	MOV	M,A
	INX	H
	RET
	SPACE	3,10
PFIA	DS	0		BUFFER AREA FOR LINE BUILD
	DB	'FILENAME.EXT.NNNNN.NNNNN..DD-MMM-YY..HH:MMz'
	DB	'..SLWCABDU..01234567..DD-MMM-YY..NNN',0

PFIB	DB	'SLWCABDU'	FLAG CODES
	ERRNZ	DIF.SYS-200Q
	ERRNZ	DIF.LOC-100Q
	ERRNZ	DIF.WP-40Q
	ERRNZ	DIF.CNT-20Q
	ERRNZ	DIF.ARC-10Q
	ERRNZ	DIF.BAD-4
	ERRNZ	DIF.DL-2
	ERRNZ	DIF.USR-1

PFID	DB	0		FILE COUNT FOR /B
PFIDIR	DW	0		TEMP DIR POINTER
PFIS	DW	0		FILE SIZE WITHOUT LAST CLUSTER
PFIT	DB	0		TEMP TIME BYTE

	IF	USER
PFIU	DB	'01234567'	USER CODES
	ENDIF
